<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IO多路复用]]></title>
    <url>%2F2018%2F03%2F25%2FPython%2FConcurrency%2FProcessesAndThreads%2FIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[线程池和进程池]]></title>
    <url>%2F2018%2F03%2F25%2FPython%2FConcurrency%2FProcessesAndThreads%2F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[队列]]></title>
    <url>%2F2018%2F03%2F16%2FPython%2FConcurrency%2FProcessesAndThreads%2F%E9%98%9F%E5%88%97%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[多进程和多线程]]></title>
    <url>%2F2018%2F03%2F16%2FPython%2FConcurrency%2FProcessesAndThreads%2F%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在学习 Python 的中多进程和多线程之前，要弄清楚什么是进程？ 而什么又是线程？ 什么是进程(Process) 对于操作系统来说，一个任务就是一个进程，比如打开 PyCharm 就是启动了 PyCharm 进程，打开 QQ 就是启动了 QQ 进程，每一个进程的启动都会先产生一个线程，就是主线程，然后由这个主线程去创建其它子线程 什么是线程(Thread) 线程被包含在进程中，是进程实际的运作单位，被称为微进程，一个进程中可以有多个线程，一个进程可以同时并发多个线程，每条线程并行执行不同的任务 进程和线程的区别 进程之间是相互独立的，多进程中的，进程之间的变量是不会相互影响的，但是一个进程内的多个线程是内存共享的，所以线程间的变量是共享的 因为进程之间是相互独立的，所以进程间的崩溃不会影响到其它进程，但是由于线程是包含在进程内部的，所以线程的崩溃会引发进程的崩溃，继而造成同一进程中的其它线程也崩溃 进程的启动速度慢，线程的启动速度快，但是两者运行速度没有可比性 并行和比并发的理解并行是并发，但是并发不一定是并行，并行需要满足的要求是:CPU的核心数大于进程的数量，这才是并行，如果 CPU 的核心数小于进程的数量，那么就是并发了，不能称为并行，所以说，并行是并发，但是并发不是并行 创建进程(Process) os模块的fork方法可以在进程，但是这个只能在Linux/unix/mac上使用，而且比较特殊，别的函数，调用一次，返回一次，但是 fork() 调用一次，返回两次，因为操作系统自动把当前进程（也就是父进程）复制了一份进程（就是子进程），然后分别在父进程和子进程内返回 子进程永远返回 0，而父进程返回子进程的 Pid ，原因是因为，一个父进程可以 fork 出很多子进程，所以父进程要记录下每一个子进程的 Pid, 子进程调用 getppid 则可以获取父进程的 pid 123456789101112import os"""getpid 可以获取当前进程的进程号getppid 可以获取父级进程的进程号"""print('父进程', os.getpid())pid = os.fork()# 子进程永远都是返回 0if pid == 0: print('子进程&#123;&#125;, 父进程&#123;&#125;'.format(os.getpid(), os.getppid()))else: print('父进程&#123;&#125;, 子进程&#123;&#125;'.format(os.getpid(), pid)) 运行结果如下： 123父进程 2831父进程2831, 子进程2832子进程2832, 父进程2831 因为 fork() 函数在 Windows 上是无效的，所以有了 multprocessing 跨平台的多进程模块，这个模块的 Process 类提供了进程对象123456789101112131415import multiprocessingimport timeimport osdef func(): time.sleep(3) print('子进程&#123;&#125;'.format(os.getpid()))if __name__ == '__main__': print('父进程&#123;&#125;'.format(os.getpid())) print('子进程开始...', time.strftime('%H:%M:%S', time.localtime())) p = multiprocessing.Process(target=func) p.start() # 开始启动进程 p.join() # 等待进程执行完毕 print('子进程结束...', time.strftime('%H:%M:%S', time.localtime())) 运行结果如下：1234父进程2879子进程开始... 18:39:39子进程2880子进程结束... 18:39:42 通过 Process 创建子进程实例的时候，需要通过 target 参数来传入一个 执行函数，当然， Process 不仅仅如此，还可以传入 args （位置参数）和 kwargs （关键字参数），创建完进程后，使用 start() 来启动，这种方式创建进程比 fork() 要简单join() 方法，就是父进程只有等待子进程执行完毕后，才会继续往下执行，一般用于进程间的同步 创建线程(Thread)和进程的 multprocessing 模块一样，线程也有一个属于自己的模块 threading, threading 模块提供了一个 Thread 用于创建线程 12345678910import threadingprint('主线程开始', threading.current_thread().name)def func(): print('子线程',threading.current_thread().name)t = threading.Thread(target=func)t.start()t.join()print('主线程结束',threading.current_thread().name) 线程的创建和进程区别并不大，线程是通过一个 Thread 类实例化一个线程, 然后调用 start() 启动线程，调用 join() 将子线程挂起，让主线程等待子线程结束，然后主线程才结束， 计算密集型任务和 IO密集任务 计算密集（耗时任务）用进程，IO密集（阻塞任务）用线程，因为线程遇到阻塞会自动切换，耗时和阻塞的区别在于，耗时就是会一直占用 CPU 进行做运算， 阻塞则是指的是 让 CPU 休眠 123456789101112# 阻塞 time.sleep 表示阻塞任务def func(): time.sleep(5)# 耗时任务 fib 表示耗时任务def fib(n): if n == 0: return 1 elif n == 1: return 1 else: return fib(n-1) + fib(n-2) 使用多进程实现并行1234567891011121314151617import multiprocessingimport timeprint('fib start...', time.strftime('%H:%M:%S', time.localtime()))def fib(n): if n == 0: return 1 elif n == 1: return 1 else: return fib(n-1) + fib(n-2)p = multiprocessing.Process(target=fib, args=(35,))p.start()print(fib(35))p.join()print('fib end...', time.strftime('%H:%M:%S', time.localtime())) 使用多线程避免阻塞多线程避免阻塞，使用 socket 本身的阻塞做为例子 服务端：1234567891011121314151617181920212223import socketfrom threading import Threadserver = socket.socket()server.bind(('', 8888))server.listen(1000)# 接收数据def read(conn, raddr): while True: data = conn.recv(1000) if data: print(data.decode('utf-8')) conn.send(data) else: conn.close() breakwhile True: connection, remote_address = server.accept() # 使用多线程防止阻塞 t = Thread(target=read, args=(connection, remote_address)) t.start() 客户端：12345678910111213import socketclient = socket.socket()client.connect(('localhost', 8888))while True: msg = input('&gt;&gt;') client.send(msg.encode('utf8')) data = client.recv(1000) if data: print(data.decode('utf-8')) else: client.close() break 这个就是使用多线程实现非阻塞的套接字的一个典型例子，每接收到一个客户端的连接，就分配一个线程去接收，这里要注意，不要使用 join()，因为一旦使用了，就表示只有当前线程结束后，才会开始下一次线程，当然，这是多线程实现非阻塞的套接字，使用多进程同样也是可以的，但是，使用多进程，比较损耗 CPU ，所以当遇到阻塞，要使用线程，因为线程遇到阻塞会自动切换]]></content>
      <categories>
        <category>Python</category>
        <category>多进程和多线程</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socket]]></title>
    <url>%2F2018%2F03%2F15%2FPython%2FConcurrency%2FProcessesAndThreads%2FSocket%2F</url>
    <content type="text"><![CDATA[socket 通信]]></content>
  </entry>
  <entry>
    <title><![CDATA[Event]]></title>
    <url>%2F2018%2F03%2F12%2FJavascript%2FEvent_02%2F</url>
    <content type="text"><![CDATA[delegate 事件委托事件中一个很重要的概念 事件委托 ,对于事件处理程序过多,绑定过多的重复事件损耗性能.事件委托其实就是指定一个处理程序,管理某一类型所有的事件.利用了事件冒泡的原理. 在event事件对象中两个属性currentTarget target ,分别为当前事件对象、目标事件对象. 123456789101112&lt;div id="box"&gt;box&lt;/div&gt;&lt;div id="wrap"&gt;&lt;a&gt;click&lt;/a&gt;&lt;/div&gt;&lt;script&gt; box.onclick = function(e)&#123; console.log(e.currentTarget === e.target); // true &#125; wrap.onclick = function(e)&#123; console.log(e.currentTarget === e.target); // 如果点级的是 a ---&gt; false // 如果点击的是 div ---&gt; true &#125;&lt;/script&gt; 如果wrap中有很多a标签都需要设置点击一下改变字体样式,肯定会写很多的重复的点击事件,利用委托就很容易做到,减少DOM添加事件次数 12345wrap.onclick = function(e)&#123; if(e.target.tagName === 'A')&#123; // 代码 &#125;&#125; 过去当不知道利用事件委托的时候,有一个场景出错率很大.简单的说明一下 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;button id="add"&gt;add p element&lt;/button&gt;&lt;div id="box"&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;4&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var pDoms = document.querySelectorAll('#box p'); var boxDom = document.getElementById("box"); var btnDom = document.getElementById("add"); for(var i=0;i&lt;pDoms.length;i++)&#123; pDoms[i].onclick = function()&#123; alert(this.innerHTML); &#125; &#125; btnDom.onclick = function()&#123; boxDom.innerHTML += '&lt;p&gt;'+Math.random()+'&lt;/p&gt;'; &#125; // 没有去点击add时, 之前绑定的事件都存在.当点击add之后前边的事件全丢失了.这个是innerHTM去添加节点出现的问题,点击添加放上去的节点已非原来的节点了. // 解决方式1: 创建节点并追加, 这样子可以保留原来的 btnDom.onclick = function()&#123; var p = document.createElement("p"); p.innerText = Math.random(); p.onclick = function()&#123; alert(this.innerHTML)&#125; boxDom.append(p); &#125; // 方式2: 把事件绑定到标签中 原来的事件自然也要绑定到标签中 btnDom.onclick = function()&#123; boxDom.innerHTML += '&lt;p onclick="fn(this)"&gt;&lt;/p&gt;'; &#125; // 方式3: innerHTML添加之后在重新绑定一次事件 麻烦到家 // 方式4: 委托 boxDom.onclick = function(e)&#123; if(e.target.tagName === 'P')&#123; alert(e.target.innerHTML); &#125; &#125;&lt;/script&gt; 需要说明一下,这里绑定事件中使用事件监听的方式当然是可以的.在jq的使用中如果不知道使用 on 绑定并且使用了方式3,那么就会出现重复绑定事件的情况了.需要注意一下. 事件触发器dispatchEvent是作为高级浏览器(如chrome、Firfox等)的事件触发器来使用的，那么什么是事件触发器？就是触发事件的东西。可能有人觉得有点莫名其妙，触发事件不是在交互中被触发的吗？的确，通常情况下，事件的触发都是由用户的行为如点击、刷新等操作实现，但是，其实有的情况下，事件的触发也可以由程序来实现，比如ajax框架的一些自定义事件。和正常事件的绑定一样。对于浏览器而言，绑定事件分为高级浏览器和IE浏览器两派，事件触发器也是分为,高级浏览器和IE两派。 在非ie中可以使用 createEvent 创建event对象，接受一个参数表示要创建的事件类型 UIEvents：一般化的 UI 事件。 鼠标事件和键盘事件都继承自 UI 事件。 DOM3 级中是 UIEvent。 MouseEvents：一般化的鼠标事件。 DOM3 级中是 MouseEvent。 MutationEvents：一般化的 DOM 变动事件。 DOM3 级中是 MutationEvent。 HTMLEvents：一般化的 HTML 事件。没有对应的 DOM3 级事件 1234567891011121314// 非ie ie9+// 创建事件对象实例var haha = document.createEvent('HTMLEvents'); // UIEvents// 初始化参数 事件名 是否冒泡 是否阻止默认事件haha.initEvent('haha', true, true);// 添加一些属性haha.name = '老狗'；haha.age = 3;// 给doucment绑定一下document.addEvenetListener('haha', function(e)&#123; alert(e.name +":"+ e.age);&#125;)// 怎么触发呢？没见过这个事件啊document.dispatchEvent(haha); 12345678// ie 不能自定义事件var haha = document.createEventObject();haha.name = '小狗';haha.age = 3;document.attachEvent('onclick', function(e)&#123; alert(e.name +":"+ e.age);&#125;)document.fireEvent('onclick',haha); 通常用来做一些自定义的事件，模拟一些事件。使用jq对应 trigger]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Event</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[event target]]></title>
    <url>%2F2018%2F03%2F09%2FJavascript%2FEvent_01%2F</url>
    <content type="text"><![CDATA[事件页面与用户之间的交互是通过事件完成的。事件是用户自身的操作或者浏览器自身的一些动作。比如常见的用户的点击，浏览器load事件。在事件发生的过程中会记录一些用户的操作信息或者浏览器的动作信息。学习事件需要了解事件的机制（冒泡、捕获），不同浏览器对dom事件的写法以及delegate，onload、domReady等等。 DOM处理事件的方式，可以写在标签中执行。也可以通过js添加属性事件例如 onclick，或者事件监听方式 123&lt;div onclick = &quot;fn()&quot;&gt;&lt;/div&gt;divDom.onclick = fn;divDom.addEventListener(&apos;click&apos;, fn); 事件流页面上执行事件时候有一个顺序 DOM流中当点击了一个div，实际上也相当于点击了body、html、window。在非IE给dom添加监听事件的方法最后一个参数代表是否捕获，默认不捕获。还是参照上边的图做一个简单的说明 123456789divDom.addEventListener('click', function()&#123; console.log('div1')&#125;, false)document.body.addEventListener('click', function()&#123; console.log('body')&#125;, false)document.documentElement.addEventListener('click', function()&#123; console.log('document')&#125;, false)window.addEventListener('click', function()&#123; console.log('window')&#125;, false)divDom.addEventListener('click', function()&#123; console.log('div2')&#125;, true)document.body.addEventListener('click', function()&#123; console.log('body')&#125;, true)document.documentElement.addEventListener('click', function()&#123; console.log('document')&#125;, true)window.addEventListener('click', function()&#123; console.log('window')&#125;, true) 当点击了 div 会优先触发父元素的捕获事件依次向子元素执行，其次在从子元素依次执行不捕获事件（冒泡阶段）。针对事件源，哪个事件写在前优先执行哪个事件。 阻止冒泡。有时候可能我们不需要事件产生冒泡，这个时候就要断绝父子关系了js中有两种方式。但是冒泡也是有好处的，不要觉得冒泡不好例如 delegate 就是利用的冒泡。 12event.cancelBubble = true; // 非标准 无兼容问题 推荐使用（真的是比另外一个好记多了）event.stopPropagation(); // 标准 事件监听IE浏览器的监听方式和其它浏览器不同 attachEvent addEventListener 两种。 12el.attachEvent(type, fn)el.addEventListener(type, fn, boolean); 两者的 type 有一点区别 IE的事件和属性添加的一样 on+type ，跨浏览器事件处理 123456789var eventHandle = function(obj, type, fn)&#123; if(obj.addEventListener)&#123; obj.addEventListener(type, fn, false); &#125;else if(obj.attachEvent)&#123; obj.attachEvent('on'+type, fn); &#125;else&#123; obj[on+'type'] = fn; &#125;&#125; 虽然可以跨浏览器使用这个方法。但是有一个问题，IE中绑定事件的传入的fn，this 指向不是当前的 obj 。 12345&lt;div id="box"&gt;点我&lt;/div&gt;&lt;script&gt; function fn()&#123;alert(this.innerText)&#125;; box.attachEvent('onclick', fn); // undefined&lt;/script&gt; 嫌弃IE可能这一点占了很大一部分，可以通过 call apply bind 来改变 this 的指向。但是低版本的IE不支持bind 绑定。修改一下 12345678910111213var eventHandle = function(obj, type, fn)&#123; if(obj.addEventListener)&#123; obj.addEventListener(type, function()&#123; fn.apply(obj, arguments) &#125;, false); &#125;else if(obj.attachEvent)&#123; obj.attachEvent('on'+type, function()&#123; fn.apply(obj, arguments); &#125;); &#125;else&#123; obj[on+'type'] = fn; &#125;&#125;; 很好，但是有点觉得这个东西有点重复把fn在提取出来 12345678910111213var eventHandle = function(obj, type, fn)&#123; var handle = function()&#123; fn.apply(obj, arguments) &#125; if(obj.addEventListener)&#123; obj.addEventListener(type, handle, false); &#125;else if(obj.attachEvent)&#123; obj.attachEvent('on'+type, handle); &#125;else&#123; obj[on+'type'] = fn; &#125; return handle&#125;; 基本上没有问题， 事件绑定之后可能回去解除绑定的函数，这个写法找不到对应的函数，需要把这个函数return出去。所以重新写一个事件处理函数添加解除绑定的方法。为了形成一个完整的处理函数，里边的每一个功能分开 1234567891011121314151617181920212223242526272829303132333435var eventHandle = function()&#123; var fire = function(el, type, fn)&#123; var handle = function()&#123; fn.apply(obj, arguments) &#125; if(obj.addEventListener)&#123; obj.addEventListener(type, handle, false); &#125;else if(obj.attachEvent)&#123; obj.attachEvent('on'+type, handle); &#125;else&#123; obj['on'+ type] = fn; &#125; return handle; &#125; var remove = function(el, type, handle)&#123; if(obj.removeEventListener)&#123; obj.removeEventListener(type, handle, false); &#125;else if(obj.deatchEvent)&#123; obj.deatchEvent('on'+type, handle); &#125;else&#123; obj[on+'type'] = null; &#125; &#125; return &#123; fire: fire, remove: remove &#125;&#125;();// testvar handle = eventHandle.fire(boxDom, 'click', function()&#123; alert(this.innerText);&#125;)eventHandle.remove(boxDom, 'click', handle); 123456789101112131415161718192021222324252627282930~function($)&#123; if(document.addEventListener)&#123; $.addEvent = function(el,type,callBack)&#123; el.addEventListener(type,callBack,false); el[type+'callBack'] = el[type+'callBack'] || []; el[type+'callBack'].push(callBack); return callBack; &#125; $.off = function(el,type,fn)&#123; if(typeof fn != 'undefined')&#123; el.removeEventListener(type,fn,false); &#125;else&#123; el[type+'callBack'].forEach(function(item)&#123; el.removeEventListener(type,item); &#125;) &#125; &#125;; &#125;else&#123; $.attachEvent = function(el,type,callBack)&#123; var bound = function()&#123; return fn.apply(el,arguments); &#125; el.attachEvent('on'+type,bound); return bound; &#125;; $.off = function(el,type,fn)&#123; el.detachEvent('on'+type,fn); &#125;; &#125;;&#125;(window); 另外尝试，因为事件监听的方式不会产生覆盖，如果想一次性清除所有的相同类型的事件可以采用上边的写法。都是简单的尝试，更多的细节也可以去查看一下jq的源码，其中对事件的处理方式很多东西值得学习。 事件对象在DOM上触发某个事件的时候会产生一个事件对象，用来记录与这个事件相关信息。非IE中这个事件对象存在于绑定函数的参数中，IE则不能直接使用这个参数而是通过访问window对象底下的event对象。 1234el.onclick = function(e)&#123; e = e || window.event; alert(e);&#125;; 阻止冒泡也是通过事件对象底下属性和方法去做到的。事件对象还能做什么呢？ 鼠标位置可以用来做很多事情。IE与非IE鼠标位置的获取不同 clientX/Y pageX/Y 区别：pageX/Y 不兼容ie9-。获取的值clientX/Y获取到可视区的距离，pageX/Y获取到浏览器的绝对距离，但是如果要在IE下获取到距离浏览器的绝对距离就需要手写了。 123456789101112function posXY(e)&#123; e = e || event; var pos = &#123;x:0, y:0&#125;; if(e.pageX)&#123; pos.x = e.pageX; pos.y = e.pageY; &#125;else&#123; pos.x = e.clientX + document.documentElement.scrollLeft; pos.y = e.clientY + document.documentElement.scrollTop; &#125; return pos;&#125; 阻止默认事件 如果调用事件的对象 cancelable 的值为true，那就表明存在默认事件。a链接，表单提交，浏览器滚动条，有时候都需要阻止其中的默认事件 w3c的方法是e.preventDefault()，IE则是使用 e.returnValue = false js中使用return false 也可以做到当然只是高级浏览器。 键码 玩过游戏的都知道键盘上我们可以控制游戏人物的方向，键盘事件中 event.keyCode 用来监听按了哪一个按键，查询对应的键码就知道按下了哪一个键。 123456document.onkeydown = function(e)&#123; e = e || event; if(e.keyCode == 13)&#123; // 回车键 // 操作 &#125;&#125; 鼠标按键 123456789101112131415161718192021// 阻止右键菜单document.oncontextmenu = function()&#123; return false;&#125;// 自定义右键菜单 0--左键 1--滚轮 2--右键document.onmousedown = function(e)&#123; e = e || event; var x = e.pageX; var y = e.pageY; if(e.button == 2)&#123; var divDom = document.createElement("div"); with(divDom.style)&#123; width = '100px'; height = '100px'; background = 'red'; position = 'absoulte'; left = x + 'px'; top = y + 'px'; &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>Event</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setInterval setTimeout（一）]]></title>
    <url>%2F2018%2F03%2F06%2FJavascript%2FsetInterval%20setTimeout%2F</url>
    <content type="text"><![CDATA[js中的定时器JavaScript是单线程语言，但它允许通过设置超时值，间歇时间值来调度代码在特定时刻执行。这两个分别是window 对象的 setTimeout 与 setInterval 方法，返回值是一个 intervalID 可以传递给 clearTimeout 与 clearInterval 简单的认识1234var intervalID1 = setTimeout(func, delay);var intervalID2 = setTimeout(func, delay, param...);var intervalID3 = setInterval(func, delay);var intervalID4 = setInterval(func, delay, param...); 先来看一下定时器的写法 1234function fn()&#123; alert(1) &#125;;setTimeout(fn, 1000);setTimeout("fn()", 1000); // 不推荐写法 evelsetTimeout(function()&#123; fn() &#125;, 1000); // 通过回调的方式调用 多了不必要的开销 但是可以去传递参数 其中要注意一点 1234window.onload = function()&#123; setTimeout("fn()", 1000); // 报错 fn is not defined 如果fn写在全局是可以的 所以这里个人认为可能是eval去解析了 字符fn() 但是fn必须是 window作用域底下的函数 局部作用域会找不到fn 虽然有点牵强但是知道有这个坑就好了 function fn()&#123; alert(1) &#125;;&#125; 当调用的函数有参数的时候 1234function fn(a, b)&#123; console.log(a, b) &#125;;setTimeout("fn(1, 2)", 1000); // 不推荐 evalsetTimeout(fn, 1000, 1, 2); // IE9-不支持第一种语法中向延迟函数传递额外参数的功能setTimeout(function(num)&#123;console.log(num)&#125;, 1000, 10); this 定时器中的this也是一个很容易出错的地方 123456789var obj = &#123; a: 10, printa()&#123; alert(this.a); &#125;&#125;var a = 20;obj.printa(); // 10 objsetTimeout(obj.printa, 1000); // 20 window setInterval 与 setTimeout 中执行的代码在一个单独的执行上下文中运行到它所调用的函数中。因此，被调用函数的this关键字将被设置为window对象，它不会与调用的函数最初的上下文环境相同 有方式解决嘛? 当然 123setTimeout(obj.printa.bind(obj), 1000); // 通过bind改变// 因为bind不兼容 可能有人在这里想这样写 setTimeout.call(obj, obj.printa, 1000), 很遗憾报错 Uncaught TypeError: Illegal invocation// 无法通过call把对象传递给回调函数 12345678910111213141516171819202122232425// 自己动手封装一下好了function setTime(callBack, delay)&#123; var content = this, args = Array.prototype.slice.call(arguments, 2); return setTimeout(function()&#123; callBack.apply(content, args); &#125;, delay)&#125; // MDN上给出了一中方法是 还是重新写了一遍var __nativeST__ = window.setTimeout, __nativeSI__ = window.setInterval;window.setTimeout = function (vCallback, nDelay ) &#123; var oThis = this, aArgs = Array.prototype.slice.call(arguments, 2); return __nativeST__(vCallback instanceof Function ? function () &#123; vCallback.apply(oThis, aArgs); &#125; : vCallback, nDelay);&#125;;window.setInterval = function (vCallback, nDelay ) &#123; var oThis = this, aArgs = Array.prototype.slice.call(arguments, 2); return __nativeSI__(vCallback instanceof Function ? function () &#123; vCallback.apply(oThis, aArgs); &#125; : vCallback, nDelay);&#125;; 区别简单的区别两者就是 setTImeout 仅会在超时值执行一次，但是这个超时值不一定是我们所设置的那个值。setInterval 会间歇性的调用，但是这个间歇时间可能会让程序出现问题。 12setTimeout(_=&gt;&#123; alert(1) &#125;, 500); // 有意思的事情就来了 弹窗并非很快的执行for(var i=0;i&lt;10e8;i++)&#123;&#125; 这个是因为window对象底下的定时器属于异步语句，js单线程的执行。当程序自上而下的去执行的时候，优先执行同步代码，浏览器会把异步的语句放入一个 异步语句列队(定时器，webAPI，DOM，ajax)，当js主线程的任务执行完毕之后在依次执行异步语句。 怎么去依次执行的异步语句呢？这个就是 delay 参数起作用了。延迟时间实际上的意思相当于 当js主线程的任务完成之后异步列队中的语句推入主线程执行的时间 12345678910setTimeout(_=&gt;&#123; console.log(1) &#125;, 500); setTimeout(_=&gt;&#123; console.log(2) &#125;, 100); setInterval(_=&gt;&#123; console.log(3)&#125;, 50)for(var i=0;i&lt;10e8;i++)&#123;&#125;/* 3 2 1 3...*/ 通过 setTimeout 可以模拟 setInterval 。更多的可能会用 out 来模拟 interval 123456// 简单的示例var fn = function()&#123; console.log(1); setTimeout(fn, 1000)&#125;fn(); setTimeout 会在fn执行从上而下执行完成，在调用下一次定时器。而 setInterval 不会等待fn执行完成而是会 到达调用时间间隔就会插入事件列队去执行。所以在做某些场景的时候不要去影响业务就好了。 定时器休眠浏览器是很智能的程序。当用户切换了当前显示的页面，或者最小化窗口的时候 setInterval 会暂时进入休眠状态，但是并不是停止，而是很缓慢，并且在这个时间段的执行语句都会放入一个列队，当用户再次进入页面的时候会一次性全部执行，在很多 canvas 的效果中这个现象很普遍，以及在做无缝的轮播的时候可能也会碰到这样子的问题。贴一个链接可以去查看。Canvas实现会跳舞的时间动画 切换到其它页面等一会在切换回去就会发现问题了 123456789var index = 0;setInterval(function()&#123; document.title = ++index;&#125;, 30)// 更改title打开页面可以看到快速的变化，切换到其它的页面会发现 title的改变会变得很缓慢。就是 setInterval的休眠机制 很有趣 h5 API另外一个 window.requestAnimationFrame()function fn()&#123; document.title = ++index; window.requestAnimationFrame(fn);&#125; window.requestAnimationFrame() 比起 setInterval 会更加的稳定因为它会随着浏览器刷新频率的变化而变化做动画会更加的平滑。上边的执行当切换到其它的页面。title会停止改变，也就是说会更加的节约浏览器的开支消耗。这个不是重点。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM]]></title>
    <url>%2F2018%2F03%2F05%2FJavascript%2FBOM%2F</url>
    <content type="text"><![CDATA[ECMAScript 是 JavaScript 语法的核心规范，如果在 web 中使用 JavaScript，那么 BOM 则是一个很重要的核心。BOM提供了很多的对象，用于访问浏览器的功能。BOM最早没有一个统一的规范导致浏览器厂商都有自己的想法随意的去扩展。后来把浏览器共有的对象做为事实上的标准。这些对象在浏览器中得以存在。W3C为了把浏览器中基本的部分标准化，将 BOM 纳入了 H5 的规范中。 BOM BOM（Browser Object Model），核心对象 window 对象，它表示浏览器的一个实例。 在全局中定义的变量函数，都会被归纳在 window 对象名下 123var a = 1;console.loa(a);console.log(window.a); 因为全局变量是归属于 window 对象，但是与直接扩展在 window 上的属性有点区别：直接定义在window上的属性可以被 delete 删除，通过 var 定义的变量是不会被删除的. screen说screen对象之前先说一下确定浏览器可视窗口大小的属性 浏览器确定一个窗口的大小不是简单的事情。有四个属性 innerWidth，innerHeight，outerWidth，outerHeight。IE8 及更早版本没有提供取得当前浏览器窗口尺寸的属性；不过，它通过 DOM 提供了页面可见区域的相关信息 IE9+、 Safari 和 Firefox中， outerWidth 和 outerHeight 返回浏览器窗口本身的尺寸 Chrome 中， outerWidth、 outerHeight 与innerWidth、 innerHeight 返回相同的值 document.documentElement.clientWidth 和 document.documentElement.clientHeight 中保存了页面视口的信息。在 IE6 中，在标准模式下才有效；如果是混杂模式，就必须通过document.body.clientWidth 和 document.body.clientHeight 取得相同信息。而对于Chrome，则无论通过 document.documentElement 还是 document.body 中的 clientWidth 和clientHeight 属性，都可以取得视口的大小。 ps ：虽然最终无法确定浏览器窗口本身的大小，但却可以取得页面视口的大小。关于浏览器的渲染模式参考 12345678910111213var pageWidth = window.innerWidth, pageHeight = window.innerHeight;if (typeof pageWidth != "number")&#123; if (document.compatMode == "CSS1Compat")&#123; pageWidth = document.documentElement.clientWidth; pageHeight = document.documentElement.clientHeight; &#125; else &#123; pageWidth = document.body.clientWidth; pageHeight = document.body.clientHeight; &#125;&#125;// 通常我们可能会这么写var pageWidth = document.documentElement.clientWidth || window.innerWidth screen对象其实没有很大的用处，screen对象可以表明浏览器的显示器信息。以像素表示 12window.screen.availWidth // 可用的屏幕宽度 减去界面特性，比如窗口任务栏window.screen.availHeight // 可用的屏幕高度 减去界面特性，比如窗口任务栏 locationlocation是BOM中很重要的对象。提供了与当前窗口相关的信息。而且 location 对象既是 window对象也是document对象 1window.location === document.location 以 https://www.baidu.com/s?wd=bom 举例说明 属性 例子 描述 hash “#content” 返回URL中的hash（#号后跟零或多个字符），如果URL中不包含散列，则返回空字符串 host “www.baidu.com&quot; 返回服务器名称和端口号（如果有） hostname “www.baidu.com&quot; 返回不带端口号的服务器名称 href https://www.baidu.com/s?wd=bom 返回当前加载页面的完整URL。而location对象的toString()方法也返回这个值 pathname “/s” 返回URL中的目录和（或）文件名 port “” 返回URL中指定的端口号。如果URL中不包含端口号，则这个属性返回空字符串 protocol “https” 返回页面使用的协议。通常是http:或https: search “?wd=bom” 返回URL的查询字符串。这个字符串以问号开头 查询参数，通过location对象可以审查到URL中的参数返回一个对象 123456789101112131415161718192021function getUrlParam()&#123; var qs = location.search; var str = qs.length &gt; 0 ? qs.substring(1) : ""; var param = &#123;&#125;; var items = str.split("&amp;"); for(var i=0,len = items.length;i&lt;len;i++)&#123; item = items[i].split("="); param[decodeURIComponent(item[0])] = decodeURIComponent(item[1]); &#125; return param;&#125;function getUrlParam()&#123; var qs = location.search; var str = qs.length &gt; 0 ? qs.substring(1) : ""; var items = qs.match(/(\w+)=(\w+)/g); return items.reduce((a, b) =&gt; &#123; var index = b.indexOf("="); return a[decodeURIComponent(b.slice(0,index))] = decodeURIComponent(b.slice(index+1)),a; &#125;,&#123;&#125;);&#125; 另外location对象中除了hash属性修改不会重新加载其它的属性修改之后都会重新加载，而且会在 history 产生一条记录，因此可以通过回退返回。可以禁止这个行为 location.replace(url); 用户不能点击返回，并且不会在 history 产生记录。 还有一个相关的方法 reload() 。重新加载当前的页面。无参数的时候会议最有效的方式加载。也就是会从浏览器缓存中加载。如果需要强制从服务器加载添加参数 true 12location.reload(); // 可能从缓存加载location.reload(true); // 从服务器加载 由于是重新载入页面所以位于 reload 之后的代码可能不在执行。所以请记得写在最后一行。 navigatorNavigator 对象包含有关浏览器的信息，每个浏览器都有自己的一套属性。 属性或方法 描述 appCodeName 浏览器的名称。通常都是Mozilla，即使在非Mozilla浏览器中也是如此 appName 完整的浏览器名称 appVersion 浏览器的版本。一般不与实际的浏览器版本对应 cookieEnabled 表示cookie是否启用 language 浏览器的主语言 onLine 表示浏览器是否连接到了因特网 oscpu 客户端计算机的操作系统或使用的CPU platform 浏览器所在的系统平台 plugins 浏览器中安装的插件信息的数组 systemLanguage 操作系统的语言 userAgent 浏览器的用户代理字符串 userLanguage 操作系统的默认语言 userProfile 借以访问用户个人信息的对象 vendor 浏览器的品牌 javaEnabled() 表示当前浏览器中是否启用了Java 这里给出一个书上的检测用于代理字符串，包括呈现引擎、平台、操作系统、移动设备和游戏系统的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160var client = function () &#123; //呈现引擎 var engine = &#123; ie: 0, gecko: 0, webkit: 0, khtml: 0, opera: 0, //完整的版本号 ver: null &#125;; //浏览器 var browser = &#123; //主要浏览器 ie: 0, firefox: 0, safari: 0, konq: 0, opera: 0, chrome: 0, //具体的版本号 ver: null &#125;; //平台、设备和操作系统 var system = &#123; win: false, mac: false, x11: false, //移动设备 iphone: false, ipod: false, ipad: false, ios: false, android: false, nokiaN: false, winMobile: false, //游戏系统 wii: false, ps: false &#125;; //检测呈现引擎和浏览器 var ua = navigator.userAgent; if (window.opera) &#123; engine.ver = browser.ver = window.opera.version(); engine.opera = browser.opera = parseFloat(engine.ver); &#125; else if (/AppleWebKit\/(\S+)/.test(ua)) &#123; engine.ver = RegExp["$1"]; engine.webkit = parseFloat(engine.ver); //确定是 Chrome 还是 Safari if (/Chrome\/(\S+)/.test(ua)) &#123; browser.ver = RegExp["$1"]; browser.chrome = parseFloat(browser.ver); &#125; else if (/Version\/(\S+)/.test(ua)) &#123; browser.ver = RegExp["$1"]; browser.safari = parseFloat(browser.ver); &#125; else &#123; //近似地确定版本号 var safariVersion = 1; if (engine.webkit &lt; 100) &#123; safariVersion = 1; &#125; else if (engine.webkit &lt; 312) &#123; safariVersion = 1.2; &#125; else if (engine.webkit &lt; 412) &#123; safariVersion = 1.3; &#125; else &#123; safariVersion = 2; &#125; browser.safari = browser.ver = safariVersion; &#125; &#125; else if (/KHTML\/(\S+)/.test(ua) || /Konqueror\/([^;]+)/.test(ua)) &#123; engine.ver = browser.ver = RegExp["$1"]; engine.khtml = browser.konq = parseFloat(engine.ver); &#125; else if (/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/.test(ua)) &#123; engine.ver = RegExp["$1"]; engine.gecko = parseFloat(engine.ver); //确定是不是 Firefox if (/Firefox\/(\S+)/.test(ua)) &#123; browser.ver = RegExp["$1"]; browser.firefox = parseFloat(browser.ver); &#125; &#125; else if (/MSIE ([^;]+)/.test(ua)) &#123; engine.ver = browser.ver = RegExp["$1"]; engine.ie = browser.ie = parseFloat(engine.ver); &#125; //检测浏览器 browser.ie = engine.ie; browser.opera = engine.opera; //检测平台 var p = navigator.platform; system.win = p.indexOf("Win") == 0; system.mac = p.indexOf("Mac") == 0; system.x11 = (p == "X11") || (p.indexOf("Linux") == 0); //检测 Windows 操作系统 if (system.win) &#123; if (/Win(?:dows )?([^do]&#123;2&#125;)\s?(\d+\.\d+)?/.test(ua)) &#123; if (RegExp["$1"] == "NT") &#123; switch (RegExp["$2"]) &#123; case "5.0": system.win = "2000"; break; case "5.1": system.win = "XP"; break; case "6.0": system.win = "Vista"; break; case "6.1": system.win = "7"; break; default: system.win = "NT"; break; &#125; &#125; else if (RegExp["$1"] == "9x") &#123; system.win = "ME"; &#125; else &#123; system.win = RegExp["$1"]; &#125; &#125; &#125; //移动设备 system.iphone = ua.indexOf("iPhone") &gt; -1; system.ipod = ua.indexOf("iPod") &gt; -1; system.ipad = ua.indexOf("iPad") &gt; -1; system.nokiaN = ua.indexOf("NokiaN") &gt; -1; //windows mobile if (system.win == "CE") &#123; system.winMobile = system.win; &#125; else if (system.win == "Ph") &#123; if (/Windows Phone OS (\d+.\d+)/.test(ua)) &#123; system.win = "Phone"; system.winMobile = parseFloat(RegExp["$1"]); &#125; &#125; //检测 iOS 版本 if (system.mac &amp;&amp; ua.indexOf("Mobile") &gt; -1) &#123; if (/CPU (?:iPhone )?OS (\d+_\d+)/.test(ua)) &#123; system.ios = parseFloat(RegExp.$1.replace("_", ".")); &#125; else &#123; system.ios = 2; //不能真正检测出来，所以只能猜测 &#125; &#125; //检测 Android 版本 if (/Android (\d+\.\d+)/.test(ua)) &#123; system.android = parseFloat(RegExp.$1); &#125; //游戏系统 system.wii = ua.indexOf("Wii") &gt; -1; system.ps = /playstation/i.test(ua); //返回这些对象 return &#123; engine: engine, browser: browser, system: system &#125;;&#125;();console.log(client);/* &#123;engine: &#123;…&#125;, browser: &#123;…&#125;, system: &#123;…&#125;&#125;*/ historyhistory 对象保存着用户上网的历史记录。history 存在一个 go() 方法，用于前进或后退 12history.go(-1); // 后退一页history.go(1)； // 前进一页 此外还有另外两个方法 forward() back() 与 go() 方法的前进后退一致。这里可以利用JavaScript的阻塞原理做一些小的功能。alert、confirm、prompt都可以让页面阻塞执行 1234567891011// 现在有一个小的功能点击某个链接 但是需要验证一些信息var submit = document.getElementById("submit");submit.onclick = function()&#123; var flag = confirm("你是不是我的小可爱,请回答是或者不是"); if(flag)&#123; window.location.href = "https://www.baidu.com"; &#125;else&#123; // window.history.go(-1); window.history.back(); &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>BOM</category>
      </categories>
      <tags>
        <tag>BOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript XML]]></title>
    <url>%2F2018%2F03%2F03%2FJavascript%2Fjavascript-XML%2F</url>
    <content type="text"><![CDATA[XML曾经做为存储和通过网络传输结构化数据的标准。微型的结构化的数据库，保存一些小型数据。从这里边可以看到 web 的发展 DOM 的发展。DOM的出现使得浏览器都内置了对 XML 的支持。 XML DOM 在没有正式规范之前，浏览器对 XML 的解析支持度参差不齐，DOM2 增加了对 XML DOM 的方法。DOM3 也进一步加强了。谈到标准就一定不能忘记老 IE 了。 IE 中 XMLIE 浏览器是第一个原生支持XML的浏览器，而它是通过 ActiveX 对象实现的。这个对象，只有IE有，一般是IE9之前采用。 12345创建 XMLDOM对象 IEMSXML2.DOMDocument.3.0 在JavaScript中使用，这是最低的建议版本MSXML2.DOMDocument.6.0 脚本能够可靠处理的最新版本MSXML2.DOMDocument 仅针对IE5.5之前的版本这三个版本常用其它的不稳定 采取向下兼容的方式写兼容。 12345678910111213141516function createXmlDom() &#123; var version = [ 'MSXML2.DOMDocument.6.0', 'MSXML2.DOMDocument.3.0', 'MSXML2.DOMDocument' ]; for (var i = 0; i &lt; version.length; i ++) &#123; try &#123; var xmlDom = new ActiveXObject(version[i]); return xmlDom; &#125; catch (e) &#123; //跳过 &#125; &#125; throw new Error('您的系统或浏览器不支持MSXML！'); //循环后抛出错误&#125; 创建了xmlDom对象之后，载入xml，两种方式。第一种加载外部的xml文件，并序列化 123var xmlDom = createXmlDom();xmlDom.load('src');xmlDom.xml 第二种载入 xml字符串，并序列化 123var xmlDom = createXmlDom();xmlDom.loadXML("&lt;root&gt;&lt;user&gt;Kobe&lt;/user&gt;&lt;/root&gt;");xmlDom.xml 需要注意的是 load 方法用于服务器端，所以存在 同步 or 异步, 服务器端默认异步加载 123xmlDom.async = false; // 同步xmlDom.load('src.xml');xmlDom.xml; // 打印 1234567891011121314151617xmlDom.async = true; //同步设置false，异步设置true，默认是异步xmlDom.load('src.xml');xmlDom.onreadystatechange = function () &#123; if (xmlDom.readyState == 4) &#123; if (xmlDom.parseError.errorCode == 0) &#123; //alert(this === xmlDom); //this执行的是window xmlDom.xml // 打印 &#125; else &#123; throw new Error( '错误代号：' + xmlDom.parseError.errorCode + '\n' + '错误行号：' + xmlDom.parseError.line + '\n' + '错误位置：' + xmlDom.parseError.linepos + '\n' + '错误解释：' + xmlDom.parseError.reason + '\n' + ); &#125; &#125;&#125; parseError是微软提供的如果说出现了解析错误，帮助排错的。 属性 说明 errorCode 发生的错误类型的数字代号 filepos 发生错误文件中的位置 line 错误行号 linepos 遇到错误行号那一行上的字符的位置 reason 错误的解释信息 DOM2 XML在支持 DOM2 级的浏览器中可以创建一个空白的 XML 文档，实际中很少会创建一个空白的 XML 文档。只有火狐支持 load 载入 xml文件 123456789101112131415161718// DOM2 创建var xmlDom = document.implementation.createDocument('', 'root', null);console.log(xmlDom.documentElement.nodeName); // root// 节点操作var user = xmlDom.createElement('user');xmlDom.documentElement.appendChild(user);// 序列化var serializer = new XMLSerializer();var xml = serializer.serializeToString(xmlDom);console.log(xml);// ---// 加载 xml firfox 支持load!!!!!! 并且不放在服务器上还是默认异步的xmlDom.async = false;xmlDom.load("src.xml");var serializer = new XMLSerializer();var xml = serializer.serializeToString(xmlDom);console.log(xml); 1234567xmlDom.async = true;xmlDom.load("src.xml");xmlDom.onload = function()&#123; var serializer = new XMLSerializer(); var xml = serializer.serializeToString(xmlDom); console.log(xml);&#125; 由于只有火狐支持 load 载入，所以还可以通过解析 xml字符 12345678var parser = new DOMParser();var xmlStr = '&lt;root&gt;&lt;user&gt;Lee&lt;/user&gt;&lt;/root&gt;';// parseFromString 第二个参数为解析成什么类型 不能解析htmlvar xmlDom = parser.parseFromString(xmlStr, 'text/xml');// 解析 序列化var serializer = new XMLSerializer();var xml = serializer.serializeToString(xmlDom);alert(xml); 错误解析。如果 parseFromString 解析错误会返回一个parsererror 元素，通过对它的判断 1234567891011121314var parser = new DOMParser();var xmlDom, errors;try&#123; xmlDom = parser.parseFromString(); errors = xmlDom.getElementsByTagName('parsererror'); if (errors.length &gt; 0) &#123; throw new Error('XML格式有误：' + errors[0].textContent); &#125;&#125;catch(e)&#123; alert('error');&#125;var serializer = new XMLSerializer();var xml = serializer.serializeToString(xmlDom); 跨浏览器处理 XML 123456789101112131415161718192021222324function parseXML(xml)&#123; var xmlDom = null; if(typeof DOMParser != 'undefined')&#123; xmlDom = (new DOMParser()).parseFromString(xml, 'text/xml'); var errors = xmlDom.getElementsByTagName('parsererror'); if (errors.length &gt; 0) &#123; throw new Error('XML格式有误：' + errors[0].textContent); &#125; &#125;else if(typeof ActiveXObject != 'undefined')&#123; var xmlDom = createXmlDom(); xmlDom.loadXML(xml); if(xmlDom.parseError.errorCode != 0)&#123; throw new Error( '错误代号：' + xmlDom.parseError.errorCode + '\n' + '错误行号：' + xmlDom.parseError.line + '\n' + '错误位置：' + xmlDom.parseError.linepos + '\n' + '错误解释：' + xmlDom.parseError.reason + '\n' + ); &#125; &#125;else&#123; throw new Error("No xml available"); &#125; return xmlDom;&#125;; 序列化 XML 1234567891011function serializeXML(xmlDom) &#123; var xml = ''; if (typeof XMLSerializer != 'undefined') &#123; xml = (new XMLSerializer()).serializeToString(xmlDom); &#125; else if (typeof xmlDom.xml != 'undefined') &#123; xml = xmlDom.xml; &#125; else &#123; throw new Error('无法解析XML！'); &#125; return xml;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>XML</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>DOM</tag>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM 节点操作]]></title>
    <url>%2F2018%2F03%2F03%2FJavascript%2Fcold-active-dom%2F</url>
    <content type="text"><![CDATA[DOM 操作 - colddom的操作有很多在平时操作中很少用到的，但是却十分好用的API。 insert与 insertBefore 类似的几个 API 查看 MDN开发者手册，在这里赘述一下。 1234567891011121314151617181920改方法将一个给定的元素节点插入到相对于被调用的元素的给定的一个位置。1. node.insertAdjacentElement(position, element)将指定的文本解析为HTML或XML，并将结果节点插入到DOM树中的指定位置。它不会重新解析它正在使用的元素，因此它不会破坏元素内的现有元素。这避免了额外的序列化步骤，使其比直接innerHTML操作更快。如果只是为了插入文本内容(而不是HTML节点), 不建议使用这个方法, 建议使用node.textContent 或者 node.insertAdjacentText() . 因为这样不需要经过HTML解释器的转换, 性能会好一点.看到这想说为什么不用innerHTML innerHTML不属于标准DOM 所以并没有被推荐，但是innerHTML的性能也是很好2. node.insertAdjacentHTML(position, element)将一个给定的文本节点插入在相对于被调用的元素给定的位置。3. node.insertAdjacentText(position, element)参数示意 三个方法都具有四个位置position&lt;!-- beforebegin --&gt;&lt;p&gt; &lt;!-- afterbegin --&gt; foo &lt;!-- beforeend --&gt;&lt;/p&gt;&lt;!-- afterend --&gt; example 123&lt;div id="box"&gt; &lt;div class="line"&gt;&lt;/div&gt;&lt;/div&gt; 123456789101112131415var boxDom = document.getElementById("box");var pDom1 = document.createElement("p");pDom1.insertAdjacentText('afterbegin', "afterbegin");var pDom2 = document.createElement("p");pDom2.insertAdjacentText('beforeend', "beforeend");boxDom.insertAdjacentElement('afterbegin', pDom1);boxDom.insertAdjacentElement('beforeend', pDom2);/* change &lt;div id="box"&gt; &lt;p&gt;afterbegin&lt;/p&gt; &lt;div class="line"&gt;&lt;/div&gt; &lt;p&gt;beforeend&lt;/p&gt; &lt;/div&gt;*/ example 123456789101112&lt;style&gt; div &#123;width: 50px; height: 50px; margin: 3px; border: 3px solid black; display: inline-block; background-color: red; float: left&#125; section&#123;overflow: hidden;&#125;&lt;/style&gt;&lt;p&gt;点击彩色框选择它，然后使用下面的前两个按钮在选择之前和之后插入元素。&lt;/p&gt;&lt;section&gt; &lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/section&gt;&lt;button class="before"&gt;Insert before&lt;/button&gt;&lt;button class="after"&gt;Insert after&lt;/button&gt;&lt;button class="reset"&gt;Reset demo&lt;/button&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455var beforeBtn = document.querySelector('.before');var afterBtn = document.querySelector('.after');var resetBtn = document.querySelector('.reset');var container = document.querySelector('section');var activeElem;resetBtn.addEventListener('click', function() &#123; while (container.firstChild) &#123; container.removeChild(container.firstChild); &#125; for(i = 0; i &lt;=3; i++) &#123; var tempDiv = document.createElement('div'); container.appendChild(tempDiv); setListener(tempDiv); &#125;&#125;);beforeBtn.addEventListener('click', function() &#123; var tempDiv = document.createElement('div'); tempDiv.style.backgroundColor = randomColor(); activeElem.insertAdjacentElement('beforebegin',tempDiv); setListener(tempDiv);&#125;);afterBtn.addEventListener('click', function() &#123; var tempDiv = document.createElement('div'); tempDiv.style.backgroundColor = randomColor(); activeElem.insertAdjacentElement('afterend',tempDiv); setListener(tempDiv);&#125;);function setListener(elem) &#123; elem.addEventListener('click', function() &#123; var allElems = document.querySelectorAll('section div'); for(i = 0; i &lt; allElems.length; i++) &#123; allElems[i].style.border = '3px solid black'; &#125; elem.style.border = '3px solid aqua'; activeElem = elem; &#125;)&#125;;function randomColor() &#123; function random() &#123; var result = Math.floor(Math.random() * 255); return result; &#125; return 'rgb(' + random() + ',' + random() + ',' + random() + ')';&#125;function init() &#123; var initElems = document.querySelectorAll('section div'); for(i = 0; i &lt; initElems.length; i++) &#123; setListener(initElems[i]); &#125;&#125;;init(); scrollIntoView MDN官网注解 scrollIntoView：让当前的元素滚动到浏览器窗口的可视区域内。 ​参数 （boolean | object） boolean 如果为true，元素的顶端将和其所在滚动区的可视区域的顶端对齐。 如果为false， 元素的底端将和其所在滚动区的可视区域的底端对齐。 object {block: ‘start’} 对应boolean true {block:’end’} 对应boolean false object中还有一个key behavior 三种值 auto、instant、smooth 其中 smooth 支持动画效果 obj.scrollIntoView( {block: true, behavior: ‘smooth’} ) 12345678&lt;style&gt;#up,#down&#123;width: 120px;height: 30px;text-align: center;line-height: 30px;position: fixed;right: 10px;top: 330px;background: red;color: #fff;&#125;#down&#123;top: 380px&#125;#wrap&#123;height: 20vh;background: skyblue;margin-top: 100vh;&#125;&lt;/style&gt;&lt;div id="wrap"&gt;&lt;/div&gt;&lt;div id="up"&gt;up&lt;/div&gt;&lt;div id="down"&gt;down&lt;/div&gt; 123456789101112131415161718var wrap = document.getElementById("wrap");var up = document.getElementById("up");var down = document.getElementById("down");up.addEventListener('click',function()&#123; // wrap.scrollIntoView(true) wrap.scrollIntoView(&#123; block: 'start', behavior: 'smooth' &#125;);&#125;);down.addEventListener('click',function()&#123; // wrap.scrollIntoView(false) wrap.scrollIntoView(&#123; block: 'end', behavior: 'smooth' &#125;);&#125;); scrollIntoViewIfNeeded MDN官方注解 用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。 如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动。 此方法是标准的 Element.scrollIntoView() 方法的专有变体。 PS：MDN官方说一个说明 这个是非标注的一个方法。其中有些小问题 参数 （booean） true 则元素将在其所在滚动区的可视区域中居中对齐。 false 可视区顶部，或者底部 补充说明 scrollIntoViewIfNeeded是比较懒散的，如果元素在可视区域，那么调用它的时候，页面是不会发生滚动的其次是scrollIntoViewIfNeeded只有Boolean型参数，没有动画。 不是全部可见或者全部不可见的情况下，调用scrollIntoViewIfNeeded时，无论参数是true 还是false ，都会发生滚动而且效果是滚动到元素与可视区域顶部或底部对齐，元素离哪端更近，往那边靠。 PS：scrollIntoViewIfNeeded 完全不可见的情况下 元素距离那边近 true，false 效果都一样就近原则 移动端，以及原生的使用页面滚动的时候采用jQuery动画操作，现在的原生API都这么好用。当然如果不考虑兼容问题（IE 移动端的UC浏览器不支持）这个是不错的选择 12345678910&lt;style&gt; #up,#center,#down&#123;width: 120px;height: 30px;text-align: center;line-height: 30px;position: fixed;right: 10px;top: 330px;background: red;color: #fff;&#125; #center&#123;top: 380px&#125; #down&#123;top: 430px&#125; #wrap&#123;height: 20vh;background: skyblue;margin-top: 100vh;&#125;&lt;/style&gt;&lt;div id="wrap"&gt;&lt;/div&gt;&lt;div id="up"&gt;up&lt;/div&gt;&lt;div id="center"&gt;center&lt;/div&gt;&lt;div id="down"&gt;down&lt;/div&gt; 1234567891011121314var wrap = document.getElementById("wrap");var up = document.getElementById("up");var down = document.getElementById("down");up.addEventListener('click',function()&#123; wrap.scrollIntoView(true);&#125;);center.addEventListener('click',function()&#123; wrap.scrollIntoViewIfNeeded(true);&#125;);down.addEventListener('click',function()&#123; wrap.scrollIntoViewIfNeeded(false);&#125;);]]></content>
      <categories>
        <category>JavaScript</category>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM的操作]]></title>
    <url>%2F2018%2F03%2F01%2FJavascript%2FDOM-03%2F</url>
    <content type="text"><![CDATA[DOM的操作，包括节点的获取、创建节点属性、添加节点、设置节点标签属性、类名操作 节点的获取 document.getElementById(id) document.getElementsByName(name) document.getElementsByTagName(tag) document.getElementsByClassName(class) document.querySelector(选择器) document.querySelectorAll(选择器) 最上边的三个方法无兼容问题，其余的获取方式都为 IE9+ 这里说一下其它的一点小区别 表单中通过getElementsByName获取 12345678&lt;form&gt; &lt;input type="text" name="txt" /&gt; &lt;input type="password" name="pwd" /&gt;&lt;/form&gt;&lt;script&gt; var txt = document.getElementsByName("txt")[0]; var pwd = document.getElementsByName("pwd")[0];&lt;/script&gt; class 与 tag 获取为动态获取，区别 querySelectorAll 12345678910111213141516171819202122232425&lt;style&gt; .red&#123;color: red;&#125; .green&#123;color: green;&#125;&lt;/style&gt;&lt;div class="green"&gt;1&lt;/div&gt;&lt;div class="green"&gt;2&lt;/div&gt;&lt;div class="green"&gt;3&lt;/div&gt;&lt;div class="green"&gt;4&lt;/div&gt;&lt;script&gt; // 1 var divDoms = document.getElementsByClassName("green"); for(var i=0;i&lt;divDoms.length;i++)&#123; if(divDoms[i].className === 'green')&#123; divDoms[i].className = 'red' &#125; &#125; // 2 var divDoms = document.querySelectorAll(".green") for(var i=0;i&lt;divDoms.length;i++)&#123; if(divDoms[i].className === 'green')&#123; divDoms[i].className = 'red' &#125; &#125;&lt;/script&gt; 第一个只有1，3变色。第二个全部变色。querySelectorAll返回的是节点快照，在此获取也不会改变。然而通过class获取的获取的获取都随着节点的改变而改变。二者皆有兼容问题，探讨一下 getElementsByClassName兼容问题。 1234567891011121314151617181920function getClass(name)&#123; if(document.getElementsByClassName)&#123; return document.getElementsByClassName(name); &#125;else&#123; var all = document.getElementsByTagName("*"); var res = []; // 在所有的标签里边去筛选 for(var i=0;i&lt;all.length;i++)&#123; // 类名可以是单个 也可以是多个 var clsName = all[i].className.split(' '); for(var j=0;j&lt;clsName.length;j++)&#123; if(clsName[j] == name)&#123; // all[i] 满足条件的 res.push(all[i]); &#125;; &#125; &#125;; return res; &#125;&#125;; 12345678// 另一种思路function getClass(name)&#123; var all = document.getElementsByTagName("*"); return [].slice.call(all).filter(function(item)&#123; // 把每一项的类名 切开 只要有 name这一项 返回 return item.className.split(' ').indexOf(name) != -1; &#125;);&#125;; 顺便在说一下addClass，removeClass 1234567891011121314151617181920212223function unique(arr)&#123; var res = []; for(var i=0;i&lt;arr.length;i++)&#123; for(var j=0;j&lt;res.length;j++)&#123; if(arr[i] == res[j])&#123; break; &#125; &#125; // if(j == res.length)&#123; res.push(arr[i]); &#125; &#125; return res;&#125;function addClass(ele,cname)&#123; var cArr = cname.split(' '); // 1. 判断和原来是否相等 去重 保留一个数组 // 2. 传递的和原来全都放到一起 直接去重 在拼接 var newArr = []; var arr = ele.className.split(' ').concat(cArr); ele.className = unique(newArr).join(' ');&#125; 换一个思路 1234567891011function addClass(ele, name)&#123; var arr = name.split(' ').concat(ele.className.split(' ')); ele.className = Array.from(new Set(arr)).join(' ');&#125;// h5 api classList 局限在于只能添加一个 并且不会重复添加function addClass(ele, name)&#123; name.split(' ').forEach(item=&gt;&#123; ele.classList.add(item); &#125;)&#125; removeClass 12345678910111213function removeClass(ele, name)&#123; // 判断原有的和 要删除的 var arr = ele.className.split(' '); var na = name.split(' '); for(var i=arr.length;i&gt;=0;i--)&#123; for(var j=0,naLen = na.length;j&lt;naLen;j++)&#123; if(arr[i] === na[j])&#123; arr.splice(i,1); &#125; &#125; &#125;; ele.className = arr.join(' ');&#125; 1234567891011// h5 api 删除只能删除一个function removeClass(ele, name)&#123; var na = name.split(' '); if(na.length === 1)&#123; ele.classList.remove(name); &#125;else&#123; na.forEach(function(item)&#123; ele.classList.remove(item); &#125;) &#125;&#125; 以上仅仅是做一个参考，希望大家可以学以致用。不同的思路。实际中课以使用，只是做的不健壮，如果想要更加的完善可以做一些判断。 创建节点,属性 document.createElement(eName); document.createAttribute(attrName); document.createTextNode(text); document.createDocumentFragment(); 在所有节点中，文档片段没有对应的标记。是一个轻量级的文档，可以包含和控制节点，但不会像完整的文档那样占用资源，可以理解成为一个容器。当要大量添加节点时如果频繁的添加节点，可能会让页面回流重绘所以在添加的时候可以先放到这个空壳中然后一次性放入所需的地方。 添加节点 document.insertBefore(newNode,referenceNode); parentNode.appendChild(newNode); parentNode.append(text/newNode, …) 这里介绍一下 append ParentNode.append() 允许你也追加 DOMString 对象，而 Node.appendChild() 只接受 Node 对象。 ParentNode.append() 没有返回值，而 Node.appendChild() 返回追加的 Node 对象。 ParentNode.append() 可以追加几个节点和字符串，而 Node.appendChild() 只能追加一个节点。 12345678// 添加文本var cDiv = document.createElement("div");cDiv.append('div element');// 添加多个 节点与字符串var cDiv = document.createElement("p");var cSpan = document.createElement("span");cDiv.append(cSpan, "span文本"); 设置节点标签属性,类名 hasAttribute(attr) getAttribute(attr) setAttribute(attr, value) removeAttribute(attr) dataset.attr classList.remove(name) classList.add(name) attr 设置标签属性 123456789function attr(ele, value)&#123; if(typeof value == 'string')&#123; return ele.getAttribute(value); &#125;else if(typeof value == 'object')&#123; for(var k in value)&#123; ele.setAttribute(k, value[k]); &#125; &#125;&#125; removeAttr 删除标签属性 1234567function removeAttr(ele, value)&#123; if(typeof value == 'string')&#123; if(ele.hasAttribute(value))&#123; ele.removeAttribute(value); &#125; &#125;&#125; 设置data-attr属性 1234567891011121314151617181920function dataAttr(ele, key, value)&#123; var args = arguments; var len = args.length; switch(len)&#123; case 3: if(typeof value == 'string')&#123; ele.dataset[key] = value; &#125; break; case 2: if(typeof args[1] == 'object')&#123; for(var k in args[1])&#123; ele.dataset[k] = args[1][k] &#125; &#125; break; default: throw new Error('param error'); &#125;&#125; PS：需要注意一点 data-* 设置一个属性，如果想设置的属性为 data-a-b 时，使用驼峰才会生效。element.dataset[“a-b”]时非法的不被允许的。 说到标签属性就要提到一个属性 attributes 返回一个 NameNodeMap 动态集合。包含了每一个 attr 1234567891011121314&lt;div id="box" class="a" title="123" name="xx"&gt;&lt;/div&gt;&lt;script&gt; var attrs = box.attributes; // 获取属性 var title = attrs.getNamedItem("title"); // 设置属性 var haha = document.createAttribute("haha"); haha.nodeValue="haha"; attrs.setNamedItem(haha); // 删除属性 attrs.removeNamedItem("haha"); // 返回指定位置的属性 attrs.item(0) // id="box"&lt;/script&gt; 可以写一个方法用来遍历元素的标签属性 12345678910function printAttr(el)&#123; var attrs = el.attributes, len = attrs.length, arr = Array(len); for(var i=0;i&lt;len;i++)&#123; var item = attrs.item(i); arr[i] = item.nodeName + "=" + item.nodeValue; &#125; return arr;&#125; 但是在 IE7 之前的浏览器可能会返回很多没有指定的属性，事实上只需要返回需要的其它没有显示的内在的不需要显示，通过 specified 属性检测，这个属性如果为 true ,要么是HTML中存在的，要么是 setAttribute ,dataset 设置的,要是不加这个属性在 IE7 下可以遍历出100多个属性。 123456789101112function printAttr(el)&#123; var attrs = el.attributes, len = attrs.length, arr = Array(len); for(var i=0;i&lt;len;i++)&#123; var item = attrs.item(i); if(item.specified)&#123; arr[i] = item.nodeName + "=" + item.nodeValue; &#125;; &#125; return arr;&#125; 最后放一道题。给定一个DOM元素，创建一个能访问该元素所有子元素的函数，并且要将每个子元素传递给指定的回调函数。 分析一下，如果DOM是body元素其实就是和document.all 通配符获取所有的标签节点一个意思。只是多了一条输出语句，其实为了找到某写元素去做一些事情，比如查找符合要求的元素、查找匹配的元素或者内容或者类名。思路从给定DOM元素开始，依次从自己到子元素遍历，再从子元素执行相同的操作，没错就是递归。相同的问题，不断的细化。 1234567function wark_dom(dom, callBack)&#123; callback(dom); var list = dom.children; for (var i = 0; i &lt; list.length; i++) &#123; wark_dom(list[i],callback); &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM 属性和方法]]></title>
    <url>%2F2018%2F02%2F28%2FJavascript%2FDOM-02%2F</url>
    <content type="text"><![CDATA[DOM （ Document Object Model ）是针对HTML和XML文档的一个API.DOM是一个具有丰富层次的节点树,我们可以对其进行添加、删除、修改. 所以来认识一下DOM中的属性和API以及兼容问题. 节点层次DOM将 HTML 与 XML 文档绘制成由一个 根节点 发散出来的多层节点构成的树状结构（DOM树）。 所以存在很多的节点， 不同的节点在文档中表示的信息也是不同的， 每个节点有自己的特点、属性、方法。节点与节点之间存在一定的关系。直观的看一下w3c中的DOM树 Node 类型DOM1级定义了一个 Node 接口，将DOM中的所有节点类型实现，在JavaScript中做为 Node 类。（IE中访问不到，IE使用COM对象去实现的）。所有的节点都继承自 Node 类 。打开浏览器可以在开发工具中看到一个列表 每一种节点都有一个 nodeType 属性表明节点的类型，这个值用数字表示。常见有 元素节点（ELEMENT_NODE） nodeType = 1 属性节点（ATTRIBUTE_NODE）nodeType = 2 文本节点（TEXT_NODE）nodeType = 3 注释节点（COMMENT_NODE）nodeType = 9 fragment片段节点（DOCUMENT_FRAGMENT_NODE） nodeType = 11 另外还有nodeName nodeValue属性 node nodeType nodeName nodeValue 元素 1 标签名称 null 属性 2 属性名称 属性值 文本 3 #text 文本值 关系属性节点与节点之间存在一定的联系，例如 html 可以看成是 body 的父级，body 中的标签就都是 body 的子孙。所以每一个节点都有一个 childNodes 属性 列举一下常见的节点关系属性 属性 描述 parentNode 返回指定的节点在DOM树中的父节点，parentNode不能被append parentElement 返回当前节点的父元素节点,如果该元素没有父节点,或者父节点不是一个元素节点.则 返回 null childNode 返回包含指定节点的子节点的集合，该集合为即时更新的集合 children 返回 一个Node的子elements 是一个动态更新的 HTMLCollection firstChild 返回树中节点的第一个子节点，如果节点是无子节点，则返回 null firstElementChild 同上 IE9+ lastChild 返回树中节点的最后一个子节点，如果节点是无子节点，则返回 null lastElementChild 同上 IE9+ nextSibling 返回node节点紧跟在其后面的节点，如果指定的节点为最后一个节点，则返回 null nextElementSibling 同上 IE9+ previousSibling 返回当前节点的前一个兄弟节点,没有则返回 null previousElementSibling 同上 IE9+ ownerDocument 返回当前节点的顶层的 document 对象，如果在document 自身上使用此属性，返回null example 1 12345&lt;div id="box"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 12345var boxDom = document.getElementById("box");boxDom.childNodes.length // 7boxDom.children.length // 3boxDom.firstChild.nodeType // 3boxDom.firstElementChild.nodeType // 1 example 2 12&lt;div id="box"&gt;&lt;/div&gt;text&lt;div&gt;&lt;/div&gt; 123var boxDom = document.getElementById("box");boxDom.nextSibling.nodeType // 3boxDom.nextElementSibling.nodeType // 1 ps : childNodes 会获取除了元素节点的其它节点 推荐使用 children。firstChild、lastChild、nextSibling、previousSibling同样会获取到非元素节点，推荐使用另外一种但是有兼容问题需要手动做兼容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125// 兼容处理function firstChild(el)&#123; if(el.firstElementChild)&#123; return el.firstElementChild; &#125;else&#123; var f = el.firstChild; // 直到找到nodeType是1的停止 if(f &amp;&amp; f.nodeType != 1)&#123; // f = f.nextSibling; f = next(f); &#125; // while(f &amp;&amp; f.nodeType != 1)&#123; // f = f.nextSibling; // &#125; return f; &#125;&#125;function lastChild(el)&#123; if(el.lastElementChild)&#123; return el.lastElementChild; &#125;else&#123; var l = el.lastChild; // 直到找到nodeType是1的停止 if(l &amp;&amp; l.nodeType != 1)&#123; l = prev(l); &#125; return l; &#125;;&#125;// 另一种思路function lastChild(el)&#123; var index = el.children.length-1; var l = el.children[index]; while (l) &#123; if(l.nodeType == 1)break; l = el.children[index--]; &#125; return l;&#125;function next(el)&#123; if(isElement(el))return; if(el.nextElementSibling)&#123; return el.nextElementSibling; &#125;else&#123; // ie 678 var nxt = el.nextSibling; if(nxt &amp;&amp; nxt.nodeType != 1)nxt = next(nxt); // while(nxt.nodeType != 1)&#123; // nxt = nxt.nextSibling; // &#125; return nxt; &#125;;&#125;;function prev(el)&#123; if(!isElement(el))return; if(el.previousElementSibling)&#123; return el.previousElementSibling; &#125;else&#123; // ie 678 var pre = el.previousSibling; if(pre.nodeType != 1)pre = prev(pre); return pre; &#125;;&#125;;function siblings()&#123; var arr = []; var child = el.parentElement.children; for(var i=0;i&lt;child.length;i++)&#123; if(child[i] != el)&#123; arr.push(child[i]) &#125; &#125;; return arr;&#125;// 获取所有同级元素 不包含自己function siblings(el)&#123; var pDom = el.parentNode; var child = pDom.children; return [].slice.call(child).filter(function(item)&#123; return item != el; &#125;);&#125;function siblings(el)&#123; var pDom = el.parentNode; var child = [].slice.call(pDom.children); if(child.indexOf(el) != -1)child.splice(child.indexOf(el),1); return child;&#125;function siblings(el)&#123; var arr = []; var prev = el.previousElementSibling; while (prev) &#123; arr.unshift(prev); prev = prev.previousElementSibling; &#125;; // 向下找到所有的 var next = el.nextElementSibling; while (next) &#123; arr.push(next); next = next.nextElementSibling; &#125;; reutrn arr;&#125;；// 获取指定元素中的某子元素function eq(el, index)&#123; return el.children[index];&#125;// 查找指定元素中的某子元素根据 标签 id classfunction find(el, param)&#123; return [].slice.call(el.children).filter(item=&gt;( item.id == param.slice(1) || item.className.indexOf(param.slice(1)) != -1 || item.tagName.toLowerCase() == param));&#125; 12345678910// 把零散的整理起来 定义一个 domUtils对象var domUtils = &#123; first: firstChild, last: lastChild, next: next, prev: prev, siblings: siblings, eq: eq, find: find&#125; ps : 兼容的方法很多可以多多去尝试 关于text 的属性Node 节点除了关系属性之外还包含关于 Node 自己的一些属性，关于文本的。当然一般都是标签才具有这类属性，会生效。 tagName，localName 这两个属性返回的都是标签自己独有的名称，后者为小写 innerText innerHTML textContent 区别 innerText 返回元素的文本内容可读写 innerHTML 返回元素标签中的内容，可读写（标签可以被解析）innerHTML不属于规范 textContent IE9+使用 规范DOM innerText受 CSS 样式的影响，它会触发重排（reflow），但textContent不会 textContent通常具有更好的性能，因为文本不会被解析为HTML outerText outerHTML 用法和上边一样，区别在于写的时候都会把父元素删除，基本不会使用这个属性 关于位置大小的属性 offsetWidth/Height clientWidth/Height scrollWidth/Height offsetParent offsetLeft offsetTop 元素大小 自动取整round 只读属性 offsetWidth/Height = width/height + padding + border + scrollbar clientWidth/Height = width/height + padding scrollWidth/Height = width/height + padding + 溢出 元素位置 12345678910111213141516171819// 获取元素到页面的绝对距离function offset(el)&#123; var cleft = 0, ctop = 0; do&#123; ctop += elem.offsetTop || 0; cleft += elem.offsetLeft || 0; elem = elem.offsetParent; &#125; while (elem); return &#123;ctop, cleft&#125;&#125;;// 获取指定父元素 不指定到页面的绝对距离function offsetxq(el,parent,position)&#123; var pos = position || &#123;top:0,left:0&#125;; if(el == parent)return pos; pos.top += el.offsetTop; pos.left += el.offsetLeft; return offsetxq(el.offsetParent,parent,pos);&#125;; 关于节点的样式style 属性用来操作节点的 css 样式 className 属性用来获取节点的类名 style 获取的是行内样式，同样设置的也是行内样式 12el.style.color = 'red';el.style.marginLeft = '100px'; cssText 属性可以一次性写入多个css样式，连字符的样式需要转为驼峰 1el.style.cssText += 'width:100px;height:100px;backgroundColor:red'; 这里用了 += 因为cssText会覆盖原有的样式，这样子为了保存原有的,如果相同被覆盖。 问题来了怎么获取行间样式？ 123function getStyle(el, attr)&#123; return el.currentStyle? el.currentStyle[attr] : window.getComputedStyle(el, null)[attr];&#125; currentStyle 针对IE getComputedStyle 针对非IE。后者还可以获取伪元素，如果要获取伪元素（after，before）第二个参数为伪元素。getComputedStyle(el, ‘after’) getComputedStyle(el, ‘before’) PS：上边的关于元素的大小位置的获取与 getStyle 获取的区别在于前者会取整不会取到小数，两者都没有px单位。所以使用的过程中如果需要小数则选取后者。 API 中有一个方法也是可以获取的 getBoundingClientRect 这个方法返回了6个属性 12var bound = Element.getBoundingClientRect()bound.width / bound.height / bound.top / bound.left / bound.right / bound.bottom top属性获取的是 Element距离当前窗口的距离而非绝对距离，可以写一个更加完美的获取元素绝对位置的方法 12345678910111213141516171819202122var getOffsetPosition=function(elem)&#123; if ( !elem ) return &#123;left:0, top:0&#125;; var top = 0, left = 0; if ( "getBoundingClientRect" in document.documentElement )&#123; var box = elem.getBoundingClientRect(), doc = elem.ownerDocument, body = doc.body, docElem = doc.documentElement, // clientTop 获取元素顶部边框的宽度 clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0, top = box.top + (self.pageYOffset || docElem &amp;&amp; docElem.scrollTop || body.scrollTop ) - clientTop, left = box.left + (self.pageXOffset || docElem &amp;&amp; docElem.scrollLeft || body.scrollLeft) - clientLeft; &#125;else&#123; do&#123; top += elem.offsetTop || 0; left += elem.offsetLeft || 0; elem = elem.offsetParent; &#125; while (elem); &#125; return &#123;left:left, top:top&#125;;&#125; getBoundingClientRect 在做图片惰性加载的时候就显得很容易了,这里就写一下判断时候需要显示的函数 1234567// 只考虑向下滚动加载// 如果图片出现在小于等于可视窗口300的位置时候就应该让该图片显示 function isInSight(el) &#123; const bound = el.getBoundingClientRect(); const clientHeight = window.innerHeight; return bound.top &lt;= clientHeight - 300;&#125; 关于document的属性document.all 非标准 document.title document.body 返回body document.compatMode document.documentElement 返回文档对象 document.documentElement.scrollTop/Left 获取滚动条 document.documentElement.clientWidth/clientHeight 获取窗口大小 兼容 window.innerWidth/innerHeight]]></content>
      <categories>
        <category>JavaScript</category>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM 发展]]></title>
    <url>%2F2018%2F02%2F28%2FJavascript%2FDOM_01%2F</url>
    <content type="text"><![CDATA[网页生成过程、DOM发展1. 理解网页的性能,先了解一下网页的生成过程 HTML代码转化成DOM CSS代码转化成CSSOM（CSS Object Model） 结合DOM和CSSOM，生成一棵渲染树（包含每个节点的视觉信息） 生成布局（layout），即将所有渲染树的所有节点进行平面合成 将布局绘制（paint）在屏幕上 webkit渲染流程 Geoko渲染过程 从第一步到第三步都是很快速的, 第四步与第五步是很耗时的 “生成布局”（flow）和”绘制”（paint）这两步，合称为”渲染”（render）。 ps: 火狐把Layout过程成为回流是一个意思 2. 重排与重绘网页生成的时候，至少会渲染一次。用户访问的过程中，还会不断重新渲染。 以下情况, 会导致网页的重新渲染 修改DOM 修改样式表 用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等） 添加、删除元素(回流+重绘) 隐藏元素，display:none(回流+重绘)，visibility:hidden(只重绘，不回流) 移动元素，比如改变top,left(jquery的animate方法就是,改变top,left不一定会影响回流)，或者移动元素到另外1个父元素中。(重绘+回流) 对style的操作(对不同的属性操作，影响不一样) 重新渲染，就需要重新生成布局和重新绘制。前者叫做”重排”（reflow），后者叫做”重绘”（repaint）。 需要注意的是，“重绘”不一定需要”重排”，比如改变某个网页元素的颜色，就只会触发”重绘”，不会触发”重排”，因为布局没有改变。但是，“重排”必然导致”重绘”，比如改变一个网页元素的位置，就会同时触发”重排”和”重绘”，因为布局改变了。 传送门 浏览器内部工作原理 3. 对性能的影响 重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。 提高网页性能，就是要降低”重排”和”重绘”的频率和成本，尽量少触发重新渲染。 前面提到，DOM变动和样式变动，都会触发重新渲染。但是，浏览器已经很智能了，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。 12div.style.color = 'blue';div.style.marginTop = '30px'; 上述代码会触发浏览器一次的重排重绘 如果写的不好就会导致浏览器执行多次 1234div.style.color = 'blue';// 这里再次出现了元素的位置 浏览器不得不重新排列一次var margin = parseInt(div.style.marginTop);div.style.marginTop = margin + 10 + 'px'; 一般来说浏览器对于一些样式的写操作之后,出现一下的读属性操作,都会引发浏览器的重新渲染 offsetTop/offsetLeft/offsetWidth/offsetHeight scrollTop/scrollLeft/scrollWidth/scrollHeight clientTop/clientLeft/clientWidth/clientHeight getComputedStyle() 尽量不要把读写操作混到一起 123456// baddiv.style.left = div.offsetLeft + 10 + 'px';// goodvar l = div.offsetLeft;div.style.left = l + 10 + 'px'; 一般的规则是: 样式表越简单，重排和重绘就越快。 重排和重绘的DOM元素层级越高，成本就越高。 table元素的重排和重绘成本，要高于div元素 4. 提高性能的几种方式 DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作 如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。 不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。 尽量使用离线DOM，而不是真实的网面DOM，来改变元素样式。比如，操作Document Fragment对象，完成后再把这个对象加入DOM。再比如，使用 cloneNode() 方法，在克隆的节点上进行操作，然后再用克隆的节点替换原始节点。 documentFragment ( 文档片段:虚拟的节点在重复的渲染过程中避免产生渲染回流,其实可以理解为重排 ) 先将元素设为display: none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。 position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。 只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden的元素只对重绘有影响，不影响重排。 虚拟DOM框架 vue、react 使用 window.requestAnimationFrame()、window.requestIdleCallback() 这两个方法调节重新渲染 详见阮一峰大大文章 5. 什么是DOMDOM，文档对象模型（Document Object Model）。DOM是 W3C（万维网联盟）的标准，DOM定义了访问HTML和XML文档的标准。在W3C的标准中，DOM是独于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。 DOM（文档对象模型）是针对xml经过扩展用于html的应用程序编程接口，我们又叫API。DOM把整个页面映射为一个多层的节点结构，html或xml页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。 6. DOM的地位一个网页是由html来搭建结构的，通过css来定义网页的样式，而JavaScript赋予了页面的行为，通过它我们可以与页面进行交互，实现页面的动画效果等等。那javascript究竟通过什么来实现的呢？通过ECMAScript这个标准，我们可以编写程序让浏览器来解析，利用ECMAScript，我们可以通过BOM对象（即browser object model）来操作浏览器窗口、浏览器导航对象(navigator)、屏幕分辨率(screen)、浏览器历史(history)、cookie等等。但这个通过BOM来实现的交互远远不够。要实现页面的动态交互和效果，操作html才是核心。那如何操作html呢？对，就是DOM，简单的说，DOM给我们提供了用程序来动态控制html的接口，也就是早期的DHTMl的概念。因此，DOM处在javascript赋予html具备动态交互和效果的能力的核心地位上。 7. DOM的发展 DOM1、DOM2、DOM3的区别 DOM0 JavaScript在早期版本中提供了查询和操作Web文档的内容API（如：图像和表单），在JavaScript中定义了定义了’images’、’forms’等，因此我们可以像下这样访问第一张图片或名为“user”的表单 这实际上是未形成标准的试验性质的初级阶段的DOM，现在习惯上被称为DOM0，即：第0级DOM。由于DOM0在W3C进行标准备化之前出现，还处于未形成标准的初期阶段，这时Netscape和Microsoft各自推出自己的第四代浏览器，自此DOM遍开始出各种问题。 ​ DOM1 在浏览器厂商进行浏览器大站的同时，W3C结合大家的优点推出了一个标准化的DOM，并于1998年10月完成了第一级 DOM，即：DOM1。W3C将DOM定义为一个与平台和编程语言无关的接口，通过这个接口程序和脚本可以动态的访问和修改文档的内容、结构和样式 DOM1级主要定义了HTML和XML文档的底层结构。在DOM1中，DOM由两个模块组成：DOM Core（DOM核心）和DOM HTML。其中，DOM Core规定了基于XML的文档结构标准，通过这个标准简化了对文档中任意部分的访问和操作。DOM HTML则在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法，如：JavaScript中的Document对象. DOM2 在DOM1的基础上DOM2引入了更多的交互能力，也支持了更高级的XML特性。DOM2将DOM分为更多具有联系的模块。DOM2级在原来DOM的基础上又扩充了鼠标、用户界面事件、范围、遍历等细分模块，而且通过对象接口增加了对CSS的支持。DOM1级中的DOM核心模块也经过扩展开始支持XML命名空间。在DOM2中引入了下列模块，在模块包含了众多新类型和新接口： DOM视图（DOM Views）：定义了跟踪不同文档视图的接口 DOM事件（DOM Events）：定义了事件和事件处理的接口 DOM样式（DOM Style）：定义了基于CSS为元素应用样式的接口 DOM遍历和范围（DOM Traversal and Range）：定义了遍历和操作文档树的接口 百度百科完整DOM2标准 DOM3 DOM3级：进一步扩展了DOM，引入了以统一方式加载和保存文档的方法，它在DOM Load And Save这个模块中定义；同时新增了验证文档的方法，是在DOM Validation这个模块中定义的。 DOM3进一步扩展了DOM，在DOM3中引入了以下模块： DOM加载和保存模块（DOM Load and Save）：引入了以统一方式加载和保存文档的方法 DOM验证模块（DOM Validation）：定义了验证文档的方法 DOM核心的扩展（DOM Style）：支持XML 1.0规范，涉及XML Infoset、XPath和XML Base 8. 认识DOMDOM可以将任何HTML描绘成一个由多层节点构成的结构。节点分为12种不同类型，每种类型分别表示文档中不同的信息及标记。每个节点都拥有各自的特点、数据和方法，也与其他节点存在某种关系。节点之间的关系构成了层次，而所有页面标记则表现为一个以特定节点为根节点的树形结构。 12345678910111213141516&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;DOM&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;&lt;a href="http://www.baidu.com"&gt;javascript DOM&lt;/a&gt;&lt;/h2&gt; &lt;p&gt;对HTML元素进行操作，可添加、改变或移除css样式等&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Javascript&lt;/li&gt; &lt;li&gt;DOM&lt;/li&gt; &lt;li&gt;CSS&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 将HTML代码分解成DOM节点层次 文档节点的发展历史 我们说DOM文档对象模型是从文档中抽象出来的，DOM操作的对象也是文档，因此我们有必要了解一下文档的类型。文档随着历史的发展演变为多种类型，如下: ​ DOM节点的类型 DOM1级定义了一个Node接口，这个Node接口在javascript中是作为Node类型来实现的。除了IE以外，其他所有浏览器都可以访问这个类型。每个节点都有一个nodeType属性，用于表明节点的类型。节点类型通过定义数值常量和字符常量两种方式来表示，IE只支持数值常量。节点类型一共有12种，这里介绍常用的7种类型。如下图： Element(元素节点) 是组成文档树的重要部分，它表示了html、xml文档中的元素。通常元素因为有子元素、文本节点或者两者的结合，元素节点是唯一能够拥有属性的节点类型。 ​ Attr(属性节点) 代表了元素中的属性，因为属性实际上是附属于元素的，因此属性节点不能被看做是元素的子节点。因而在DOM中属性没有被认为是文档树的一部分。换句话说，属性节点其实被看做是包含它的元素节点的一部分，它并不作为单独的一个节点在文档树中出现。 ​ Text(文本节点) 是只包含文本内容的节点，在xml中称为字符数据，它可以由更多的信息组成，也可以只包含空白。在文档树中元素的文本内容和属性的文本内容都是由文本节点来表示的。 DOM的nodeType、nodeName、nodeValue 通过DOM节点类型，我们可知，可以通过某个节点的nodeType属性来获得节点的类型，节点的类型可以是数值常量或者字符常量。示例代码如下： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;nodeName,nodeValue&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!--nodeName,nodeValue实验--&gt; &lt;div id="container"&gt;这是一个元素节点&lt;/div&gt; &lt;script&gt; var divNode = document.getElementById('container'); console.log(divNode.nodeName + "/" + divNode.nodeValue); //结果: DIV/null var attrNode = divNode.attributes[0]; console.log(attrNode.nodeName + "/" + attrNode.nodeValue); //结果： id/container var textNode = divNode.childNodes[0]; console.log(textNode.nodeName + "/" + textNode.nodeValue); //结果： #text/这是一个元素节点 var commentNode = document.body.childNodes[1]; //表示取第二个注释节点，因为body下面的第一个注释节点为空白符。 console.log(commentNode.nodeName + "/" +commentNode.nodeValue); //结果： #comment/nodeName,nodeValue实验 console.log(document.doctype.nodeName + "/" + document.doctype.nodeValue); //结果： html/null var frag = document.createDocumentFragment(); console.log(frag.nodeName + "/" + frag.nodeValue); //结果： #document-fragment/null &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 总结: ​ 9. 关于domReady、onload html是一种标记语言，它告诉我们这个页面有什么内容，但行为交互是需要通过DOM操作来实现的。我们不要以为有两个尖括号就以为它是一个DOM了，html标签要通过浏览器解析才会变成DOM节点，当我们向地址栏传入一个url的时候，我们开始加载页面，就能看到内容，在这期间就有一个DOM节点构建的过程。节点是以树的形式组织的，当页面上所有的html都转换为节点以后，就叫做DOM树构建完毕，简称为domReady。 上边已经介绍了浏览器的渲染引擎的基本渲染流程 浏览器渲染要做的事情就是把css、html、图片等静态资源显示到用户的面前 渲染引擎首先通过网络获得所请求文档的内容，通常以8k分块的方法来完成： 上图就是html渲染的基本过程，但这并不包含解析过程中浏览器加载外部资源，比如图片、脚本、iframe等的一些过程。说白了，上面的4步仅仅是html结构的渲染过程。而外部资源的加载在html结构的渲染过程中是贯彻始终的，即便绘制DOM节点已经完成，而外部资源仍然可能正在加载或者尚未加载。 然而我们并不是要在去了解浏览器渲染引擎到底是怎么来工作的、我们需要了解的是domReady的实现策略 实例1 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;Dom not ready&lt;/title&gt; &lt;script&gt; document.getElementById("header").style.color = "red"; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id="header"&gt;这里是h1元素包含的内容&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 这里文字并没有变成红色,开始学习DOM的操作多少都会碰到这个问题,原因就在于没有区分清楚HTML标签与DOM节点的区别, 浏览器通过解析器解析html语义标签,解析css样式表构建生成一个DOM节点树,就叫做DOM树构建,结束的过程代表domReady 这里可以通过一个定时器来不断的去执行也可以实现效果 123setInterval(function()&#123; document.getElementById('header').style.color = 'red';&#125;,30); 虽然也可以实现效果但是用户界面总会有一个短暂的闪烁,颜色在随之改变.不利于用户的体验. 另外一个解决方式 123window.onload = function()&#123; document.getElementById('header').style.color = 'red'; &#125; 有一定了解的这里肯定会去使用window.onload 来解决这个问题,没有任何问题 window.onload方法，表示当页面所有的元素都加载完毕，并且所有要请求的资源也加载完毕才触发执行function这个匿名函数里边的具体内容。这样肯定保证了代码在domReady之后执行。使用window.onload方法在文档外部资源不多的情况下不会有什么问题，但是当页面中有大量远程图片或要请求的远程资源时，我们需要让js在点击每张图片时，进行相应的操作，如果此时外部资源还没有加载完毕，点击图片是不会有任何反应的，大大降低了用户体验。那既然window.onload方法不可行，又该怎么做呢？ 实例2 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;title&gt;Dom not ready&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 id="header"&gt;这里是h1元素包含的内容&lt;/h1&gt; &lt;script&gt; document.getElementById("header").style.color = "red"; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这里并没有考虑 domReady 程序也可以正常运行, 因为浏览器是从上而下,从左到右渲染元素的, js代码肯定会在domReady之后去执行, 那为什么还要去写domReady呢? 在编写大型项目的时候，js文件往往非常多，而且之间会相互调用，大多数都是外部引用的，不把js代码直接写在页面上。这样的话，如果有个domReady这个方法，我们想用它就调用，不管逻辑代码写在哪里，都是等到domReady之后去执行的。 jQuery中的readey事件其实就是domReady完成执行其中的代码块,算是弥补了window.onload的短板, 用的是w3c提供的DOMContentLoaded事件, 但是DOMContentLoaded不支持低版本的IE(DOMContentLoaded)MDN文档 简单的来说,在页面的DOM树创建完成后（也就是HTML解析第一步完成）即触发，而无需等待其他资源的加载。即domReady实现策略: 1234&gt; 1. 支持DOMContentLoaded事件的，就使用DOMContentLoaded事件。&gt; 2. 不支持的就用来自Diego Perini发现的著名Hack兼容。兼容原理大概就是通过IE中的document，&gt; documentElement.doScroll(&apos;left&apos;)来判断DOM树是否创建完毕。&gt; 10. javascript对DOMReady的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// 1.function ready(fn)&#123; // 目前Mozilla、Opera和webkit 525+内核支持DOMContentLoaded事件 if(document.addEventListener) &#123; document.addEventListener('DOMContentLoaded', function() &#123; document.removeEventListener('DOMContentLoaded',arguments.callee, false); fn(); &#125;, false); &#125; // 如果IE else if(document.attachEvent) &#123; // 确保当页面是在iframe中加载时，事件依旧会被安全触发 document.attachEvent('onreadystatechange', function() &#123; if(document.readyState == 'complete') &#123; document.detachEvent('onreadystatechange', arguments.callee); fn(); &#125; &#125;); // 如果是IE且页面不在iframe中时，轮询调用doScroll 方法检测DOM是否加载完毕 if(document.documentElement.doScroll &amp;&amp; typeof window.frameElement === "undefined") &#123; try&#123; document.documentElement.doScroll('left'); &#125; catch(error)&#123; return setTimeout(arguments.callee, 20); &#125;; fn(); &#125; &#125;&#125;;// 2.function myReady(fn)&#123; //对于现代浏览器，对DOMContentLoaded事件的处理采用标准的事件绑定方式 if ( document.addEventListener ) &#123; document.addEventListener("DOMContentLoaded", fn, false); &#125; else &#123; IEContentLoaded(fn); &#125; //IE模拟DOMContentLoaded function IEContentLoaded (fn) &#123; var d = window.document; var done = false; //只执行一次用户的回调函数init() var init = function () &#123; if (!done) &#123; done = true; fn(); &#125; &#125;; (function () &#123; try &#123; // DOM树未创建完之前调用doScroll会抛出错误 d.documentElement.doScroll('left'); &#125; catch (e) &#123; //延迟再试一次~ setTimeout(arguments.callee, 50); return; &#125; // 没有错误就表示DOM树创建完毕，然后立马执行用户回调 init(); &#125;)(); //监听document的加载状态 d.onreadystatechange = function() &#123; // 如果用户是在domReady之后绑定的函数，就立马执行 if (d.readyState == 'complete') &#123; d.onreadystatechange = null; init(); &#125; &#125; &#125;&#125;// jQuery实现的过程function bindReady()&#123; if ( readyBound ) return; readyBound = true; // Mozilla, Opera and webkit nightlies currently support this event if ( document.addEventListener ) &#123; // Use the handy event callback document.addEventListener( "DOMContentLoaded", function()&#123; document.removeEventListener( "DOMContentLoaded", arguments.callee, false ); jQuery.ready(); &#125;, false ); // If IE event model is used &#125; else if ( document.attachEvent ) &#123; // ensure firing before onload, // maybe late but safe also for iframes document.attachEvent("onreadystatechange", function()&#123; if ( document.readyState === "complete" ) &#123; document.detachEvent( "onreadystatechange", arguments.callee ); jQuery.ready(); &#125; &#125;); // If IE and not an iframe // continually check to see if the document is ready if ( document.documentElement.doScroll &amp;&amp; typeof window.frameElement === "undefined" ) (function()&#123; if ( jQuery.isReady ) return; try &#123; // If IE is used, use the trick by Diego Perini // http://javascript.nwbox.com/IEContentLoaded/ document.documentElement.doScroll("left"); &#125; catch( error ) &#123; setTimeout( arguments.callee, 0 ); return; &#125; // and execute any waiting functions jQuery.ready(); &#125;)(); &#125; // A fallback to window.onload, that will always work jQuery.event.add( window, "load", jQuery.ready );&#125; 各大主流JS框架中对DOMReady事件的实现 本文借鉴了很多大神的blog，自己也对DOM有了更深的理解，希望可以帮助到更多人。]]></content>
      <categories>
        <category>JavaScript</category>
        <category>DOM</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RegExp]]></title>
    <url>%2F2018%2F02%2F12%2FJavascript%2FRegExp%2F</url>
    <content type="text"><![CDATA[Regular Expression 正则表达式，又称正规表示式。使用单个字符串来描述，匹配一系列符合某个句法规则的字符串。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。正则表达式是是一种匹配模式要么匹配字符，要么匹配位置 正则表达式的应用非常的广泛，比如在dos窗口下 find 命令 dir find *.txt 找到当前目录下所有的 .txt 结尾的文件。再比如很多 IDE 工具中都有正则替换的功能。再比如替换日期格式，匹配请求头替换等等。正则让一些繁琐的处理方式变得简单。重温了一遍黑魔法正则表达式。 RegExpJavaScript中正则表达式使用包含两个方面字符方法与正则方法。不同的方法调用方式是不同的。下面列举一下 字符方法中可以接受正则表达式的方法有 split、match、replace、search 正则方法 test、exec 标识符 g（global）、i（ignoreCase）、m（multiline） 元字符元字符某些其实就是转义字符，正则表达式中常用的几个元字符 字符 含义 \d 数字 \D 非数字 \w 数字字母下划线 \W 非数字字母下划线 \s 空格 \S 非空格 \b 单词边界 \B 非单词边界 ^ 以xx开头 $ 以xx结尾 123456var pattern = /\d/;console.log(pattern.test("abc")); // falseconsole.log(pattern.test("abc1")); // truevar pattern = /\bis\b/;console.log('this is a box'.replace(pattern, 'IS')); // this IS a box 字符集字符集用来指定某一些符合特性的字符，用 [] 来表示可以是单个字符或者是一个范围 例如[abc] [0-9] 123var pattern = /[0-9a-zA-Z_]/g; // 与\w意思相同console.log(pattern.test('*')); // falseconsole.log('--abc--'.replace(pattern, 'X')); // --XXX-- 取反 字符集中使用 ^ 代表非的意思 12var pattern = /[^abc]/g;console.log('abc123'.replace(pattern, 'X')); // XXX123 js的正则中 . 也代表一个范围和上边的元字符一样代表一个范围 写成字符集可以是 [^\r\n] ，\d 可以写成 [0-9] 。 量词用来判断字符重复出现 字符 描述 ? 出现零次或者一次(最多一次) + 出现一次或者多次(最少出现一次) * 出现零次或者多次 {n} 出现n次 {n,m} 出现n到m次 {n,} 最少出现n次 123var pattern = /\d&#123;3&#125;/;var str = "123";console.log(pattern.test(str)); // true 贪婪模式 在满足匹配条件的情况下尽可能的多的去匹配 1234567891011var pattern = /\d&#123;2,5&#125;/g;var str = "123456";console.log(str.replace(pattern, 'x')); // x6var pattern = /\d&#123;2,5&#125;/;var str = "123456";console.log(str.replace(pattern, 'x')); // x6var pattern = /\d&#123;2,5&#125;/;var str = "123456";console.log(str.match(pattern)); // ["12345", index: 0, input: "123456"] 非贪婪模式 在满足条件的情况下尽可能少的去匹配 1234567891011var pattern = /\d&#123;2,5&#125;?/g;var str = "123456";console.log(str.replace(pattern, 'x')); // xxxvar pattern = /\d&#123;2,5&#125;?/;var str = "123456";console.log(str.replace(pattern, 'x')); // x3456var pattern = /\d&#123;2,5&#125;?/;var str = "123456";console.log(str.match(pattern)); // ["12", index: 0, input: "123456"] 子集子集也是分组，在正则表达式中分组是一个重要的功能 1234567var pattern = /box&#123;2&#125;/;var str = "boxx";console.log(pattern，test(str)); // true box&#123;2&#125;匹配的是x出现两次 不是box两次var pattern = /(box)&#123;2&#125;/;var str = /boxbox/;console.log(pattern.test(str)); // true 反向引用 1234var str = 'boxbox';var pattern = /(box)&#123;2&#125;/;console.log(pattern.test(str)); // trueconsole.log(/(box)\1/.test(str)); // true 反向引用顾名思义就是去引用前边的内容也就是说要一模一样。比如检测一个字符串中是否有连续出现相同的字符 1/(\w)\1/.test("pattern"); 捕获性分组 1234var str = "2018-2-13";var pattern = /(2018)-(2)-(13)/;console.log(str.match(pattern)); // ["2018-2-13", "2018", "2", "13", index: 0, input: "2018-2-13"]console.log(pattern.exec(str)); // ["2018-2-13", "2018", "2", "13", index: 0, input: "2018-2-13"] match 与 exec 返回一个数组，匹配成功，返回的数组第一项是匹配成功的字符串，其余项为 分组项 即 子集 非捕获性分组* 123var pattern = /(?:a)(b)(c)/;var str = "abc";console.log(str.match(pattern)); // ["abc", "b", "c", index: 0, input: "abc"] ?: 这个分组将不会被返回。为了整体的匹配只返回需要的 前瞻模式 1234var str = 'google'; var pattern = /goo(?=gle)/;console.log(patter.test(str)); // trueconsole.log(pattern.exec(str)); // ["goo", index: 0, input: "google"] goo 后边必须跟的是 gle 。同样捕获返回分组内容，只会返回匹配成功的字符 负向前瞻 1234567var str = "ab123";var pattern = /a(?![a-zA-Z])/g;console.log(str.replace(pattern, "X")); // aX123var str = "a123*7vv";var pattern = /\w(?!\d)/g;console.log(str.replace(pattern, 'X')); // a12X*XXX 如何实现数字的千位分隔符表示？123456789 =&gt; 123,456,789 1'123456789'.replace(/(?!^)(?=(\d&#123;3&#125;)+$)/g, ','); 或者 123var str = "box is xob";var pattern = /box|xob/g;console.log(str.replace(pattern, 'X')); 方法正则表达式提供了两个方法 test exec 这个两个方法有些地方需要注意一下 test example 123456var str = 'a';var pattern = /\w/g;console.log(pattern.test(str)); // trueconsole.log(pattern.test(str)); // falseconsole.log(pattern.test(str)); // trueconsole.log(pattern.test(str)); // false 有点奇怪是吧~ 1234var str = 'a';var pattern = /\w/;console.log(pattern.test(str)); // trueconsole.log(pattern.test(str)); // true 两个的区别在于加了 global 标识符的正则表达式的 lastIndex 属性会每次作用于正则表达式本身。lastIndex 属性为匹配文本的最后一个字符的下一个位置，所以出现了一次 true 一次 false 奇怪的现象好像看着正则表达式一点都不靠谱。 12345var str = 'a';var pattern = /\w/g;console.log(pattern.test(str), pattern.lastIndex); // true 1console.log(pattern.test(str), pattern.lastIndex); // false 0console.log(pattern.test(str), pattern.lastIndex); // true 1 只有加了 global 标识符 lastIndex 才会生效 exec example 123456var str = '1ab2cc3dd4';var pattern = /\d\w\w\d/;var ret1 = pattern.exec(str);var ret2 = str.match(pattern);console.log(ret1, pattern.lastIndex); // ["1ab2", index: 0, input: "1ab2cc3dd4"] undefinedconsole.log(ret2, pattern.lastIndex); // ["1ab2", index: 0, input: "1ab2cc3dd4"] undefined 加上 global 标识符 12345678var str = '1ab2cc3dd4';var pattern = /\d\w\w\d/g;var ret1 = pattern.exec(str);var ret2 = str.match(pattern);// 第一次console.log(ret1, pattern.lastIndex); // ["1ab2", index: 0, input: "1ab2cc3dd4"] 4// 第二次console.log(ret2, pattern.lastIndex); // ["1ab2", "3dd4"] 0 同样加了全局标识符之后 lastIndex 会随着匹配过程改变，变成全局的正则表达式 match 方法 lastIndex 是不会改变的，也不会像 exec 返回一个详细的信息包括匹配成功的位置，匹配的字符串，下一次匹配的起始位置。选择时候如果不需要这些信息完全可以使用 match 获取结果就ok，如果需要位置信息就要选择 exec 全局正则 lastIndex 改变那么就可以反复调用 exec 方法来遍历字符串中的所有匹配文本。 1234567var str = '1ab2cc3dd4';var pattern = /\d\w\w\d/g;var ret;while(ret = pattern.exec(str))&#123; console.log(ret); console.log(pattern.lastIndex + '\t' + ret.index + '\t' + ret.toString())&#125; RegExp.$1-$9 $1 - $9 属性是包含括号子集匹配的正则表达式的静态和只读属性。通过RegExp直接访问 12345var re = /(\w+)\s(\w+)/;var str = 'John Smith';str.replace(re, '$2, $1'); // "Smith, John"RegExp.$1; // "John"RegExp.$2; // "Smith" 123var date = '2018-01-10';var pattern = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;console.log(date.replace(pattern, '$2/$3/$1')) 12345678910var str = '我是&#123;&#123;name&#125;&#125;，年龄&#123;&#123;age&#125;&#125;，性别&#123;&#123;sex&#125;&#125;';var person = &#123; name:'张三', age: 20, sex: '男'&#125;var result = str.replace(/\&#123;\&#123;(.+?)\&#125;\&#125;/g,function (match, m1) &#123; return person[m1]&#125;)console.log(result); // 我是张三，年龄20，性别男 1234// 中文var pattern = /^[\\u4e00-\\u9fa5]&#123;0,&#125;$/;// 颜色var pattern = /^#([A-Fa-f0-9]&#123;6&#125;|[A-Fa-f0-9]&#123;3&#125;)$/; last正则表达式图形化界面，对于理解很有帮助 Regexper: 可视化正则表达式 在线正则表达式使用]]></content>
      <categories>
        <category>JavaScript</category>
        <category>RegExp</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object]]></title>
    <url>%2F2018%2F02%2F11%2FJavascript%2FObject%2F</url>
    <content type="text"><![CDATA[多多少少听到过一句话，javascript中一切皆对象。其中有哪些东西是我们需要了解的呢 Object ECMAScript中，引用类型是一种结构好比一个类，将数据和功能结合到一起。描述一类对象的属性和方法。 定义js中属于 Object 数据类型的很多数组、日期、正则、甚至是函数。创建对象的方式 12345// new 关键字var obj = new Object();// 字面量对象var obj = &#123;&#125;; 对象可以有自己的方法和属性，例如可以给obj扩展 property 和方法 method 123456var person = new Object();person.name = "xq";person.say = function()&#123; console.log(this.name) &#125;;// key value形式书写 key可以加引号或者不加var person = &#123;name: "xq", say: function()&#123; console.log(this.name) &#125;&#125;; 访问对象的属性和方法可以采用方括号的语法 [] 123456789console.log(person['name']);var method = 'say';person[method]();// 为什么会有这样的写法呢？var person = &#123;"e-mail": "youname@mail.com", "first name": "xx"&#125;;person.e-mail; // errorperson.first name // errorperson["e-mail"] // bingoperson["first name"] // bingo 上边访问方式可以看到也可以用一个变量，但是能去点访问就不要写变量，毕竟多一个变量多一份担忧。 in &amp; hasOwnProperty 去检测一个对象中的属性是否存在是非常必要的，比如当我们去合并数据的时候，或者对这个数据做一些筛选的时候 123456789var obj = &#123; name: "xx"&#125;// in console.log("name" in obj); // trueconsole.log("valueOf" in obj); // true// hasOwnPropertyconsole.log(obj.hasOwnProperty("name")); // trueconsole.log(obj.hasOwnProperty("valueOf")); // false 检测 name 字段都没问题返回 true ，检测 valueOf 字段结果不同，因为 valueOf 是所有对象都具有的也就是继承父类的，in是可以检测到的，相反hasOwnProperty是不会去检测继承的与在原型扩展的属性只检测自有属性 合并数据 1234567891011121314151617181920212223242526272829303132333435363738394041var date1 = &#123;a: 1, b: 2， d: 5&#125;;var date2 = &#123;b: 3, c: 4&#125;;// 将date1合并到date2中 相同的合并for(var k in date1)&#123; // 做检测是否是date1的自有属性 if(date1.hasOwnProperty(k))&#123; date2[k] = date1[k] &#125;&#125;console.log(date2); // &#123;a: 1, b: 3, c: 4, d: 5&#125;;console.log(Object.assign(&#123;&#125;, date1, date2)); // 原生提供的方法，在不破坏原有对象属性的情况下进行合并 自己也可以写一个合并数据的方法function mixin(target, source)&#123; // 不定参 var args = [].slice.call(arguments); if(args.length == 1) return target; var index = 1; while (source = args[index++]) &#123; for(var k in source)&#123; if(source.hasOwnProperty(k))&#123; target[k] = source[k]; &#125; &#125;; &#125;; return target;&#125;;function mixin(target, ...source)&#123; return source.reduce((a, b) =&gt; ( for(var k in b)if(b.hasOwnProperty(k))&#123; a[k] = b[k] &#125; return a; ), target); // source.forEach(item =&gt; &#123; // for(var k in item)if(item.hasOwnProperty(k))&#123; // target[k] = item[k] // &#125; // &#125;); // return target;&#125; delete 对象的属性和方法是可以被删除的 1234567891011var a = 1;b = 2;delete b;console.log(b); // not defined// 定义在window作用域中的属性和方法相当于对 window对象扩展属性和方法 没有var定义的会被delete删除var obj = new Object();obj.num = 10;console.log(obj.num); // 10delete obj.num;console.log(obj.num); // undefined this this是javascript中很头疼的一个东西 this，call、apply、bind 的使用与区别 12345function foo()&#123; console.log(this);&#125;foo(); // windowconsole.log(this); // window 定义在 script 标签下的全局函数相当于给 window 对象添加了一个方法上边的调用还可以写成 window.foo()。this的指向为调用该方法的对象。 12345678910var a = 20;var obj = &#123; a: 10, say: function()&#123; console.log(this.a); &#125;&#125;obj.say(); // 10window.obj.say(); // 10// this的指向都是调用这个方法的对象也就是obj 但是当把函数的引用指向一个变量的时候就有点问题了 123var fn = obj.say;fn(); // undefinedwindow.fn(); // 相当于此 this === window this的指向都是调用它的那个对象 this 指向的偏移，打一个不恰当的比方就相当于移情别恋了。。。 call 123456789101112var a = &#123; name: '如花', say: function()&#123; console.log("你只能爱我一人。。。"+ this.name); &#125;&#125;var b = &#123; name: '凤姐'&#125;a.say(); // a爱着如花a.say.call(b); // a变心了爱上了凤姐 apply 1a.say.apply(b) // 凤姐 call apply 有什么区别呢？现在a想说点其它的，于是乎 12345678910111213var a = &#123; name: '如花', say: function(param1, param2)&#123; console.log(param1 + "你只能爱我一人。。。"+ this.name + parma2); &#125;&#125;var b = &#123; name: '凤姐'&#125;a.say('皇天在上', '永远不变'); // 皇天在上你只能爱我一人。。。如花永远不变a.say.call(b, '皇天在上', '永远不变'); // 皇天在上你只能爱我一人。。。凤姐永远不变 a.say.apply(b, ['皇天在上', '永远不变']); // 皇天在上你只能爱我一人。。。凤姐永远不变 call() 和 apply()，两个方法可用于调用函数，两个方法的第一个参数必须是对象本身。 apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。 bind bind 与 call 在传递参数上没什么区别，区别在于 bind()方法创建一个新的函数， 并且 bind 有兼容问题 123456a.say.call(b, '皇天在上', '永远不变'); // 说话了a.say.bind(b, '皇天在上', '永远不变'); // 不说话// 再次调用a.say.bind(b, '皇天在上', '永远不变')();// ora.say.bind(b)('皇天在上', '永远不变'); 还有 new 也可以改变this指向，构造函数 12345678910111213141516171819202122function Person(name, age)&#123; var obj = new Object(); obj.name = name; obj.age = age; return obj;&#125;console.log(Person("xxx", 18));function Person(name, age)&#123; this.name = name; this.age = age; console.log(this); // Person() this指向window return this;&#125;console.log(new Person('xxx', 18)); // this指向 Person对象 通过new改变了this的指向function Person(name, age)&#123; this.name = name; this.age = age; console.log(this); // Person() this指向window&#125;console.log(new Person('xxx', 18)); // 构造函数默认返回this 所以可以不写]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Date]]></title>
    <url>%2F2018%2F02%2F10%2FJavascript%2FDate%2F</url>
    <content type="text"><![CDATA[Date类型使用自UTC（Coordinated Universal Time，国际协调时间）。从1970.1.1 00:00:00开始 Date日期对象的定义 12345var date = new Date;// 可以传递参数var date = new Date(year, month, day, hours, minutes, seconds);var date = new Date(milliseconds); js还定义另外两种方法 Date.parse Date.UTC 同样可以接受参数返回毫秒数 12345var date = new Date(Date.parse("2018,02,09"));// Fri Feb 09 2018 00:00:00 GMT+0800var date = new Date(Date.UTC(2018,02,09));// Fri Mar 09 2018 08:00:00 GMT+0800// 可以发现两个日期的月份不一样 UTC格式中传入的月份 0-11 parse月份 1-12 时间差了8个小时 格式化 方法 描述 toTimeString() 把 Date 对象的时间部分转换为字符串。 toDateString() 把 Date 对象的日期部分转换为字符串。 toUTCString() 根据世界时，把 Date 对象转换为字符串。 tolocaleString() 根据本地时间格式，把 Date 对象转换为字符串。 toLocaleTimeString() 根据本地时间格式，把 Date 对象的时间部分转换为字符串。 toLocaleDateString() 根据本地时间格式，把 Date 对象的日期部分转换为字符串。 Date对象方法 方法 描述 getDate() 从 Date 对象返回一个月中的某一天 (1 ~ 31)。 getDay() 从 Date 对象返回一周中的某一天 (0 ~ 6)。 getMonth() 从 Date 对象返回月份 (0 ~ 11)。 getFullYear() 从 Date 对象以四位数字返回年份。 getHours() 返回 Date 对象的小时 (0 ~ 23)。 getMinutes() 返回 Date 对象的分钟 (0 ~ 59)。 getSeconds() 返回 Date 对象的秒数 (0 ~ 59)。 getTime() 返回 1970 年 1 月 1 日至今的毫秒数。 getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差。 tip : Date.now() 可以获取当前的毫秒。IE不支持]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array]]></title>
    <url>%2F2018%2F02%2F10%2FJavascript%2FArray%2F</url>
    <content type="text"><![CDATA[数组是 ECMAscript 中除了object之外最常用的类型了 Array数组是什么？一个盒子，一个容器，还是一个垃圾桶。 Array 类型是ECMAScript最常用的类型。而且ECMAScript中的Array类型和其他语言中的数组有着很大的区别。虽然数组都是有序排列，但ECMAScript中的数组每个元素可以保存任何类型。ECMAScript中数组的大小也是可以调整的。 数组的定义 1234567891011// 使用字面量写法创建数组var arr = [1,2,3]; // 创建了一个数字并且分配了元素// PS: var arr = [1,2,]; // 禁止使用IE会识别错误// 使用new关键字创建数组var arr = new Array(); // 创建了一个空数组var arr = new Array(7); // 创建了一个包含7个元素的数组var arr = new Array(1,2,3); // 创建了一个数组并且分配了元素// 直接Array创建var arr = Array(7); 数组的数据类型 123var arr = [];console.log(typeof arr); // objectconsole.log(Array.isArray(arr)); // true 准确判断是不是数组 注意点 1234var arr = [1,2,3];arr[5] = 'xq';console.log(arr[4]); // undefined 第3,4位没有元素被undefined所占位console.log(arr.length);// 5 使用索引也可以增加数组的长度 method 数组中的方法很多，栈方法、列队方法、重排序方法、操作方法、位置方法、迭代方法 方法 描述 push(param) 往数组的末尾添加元素 unshift(param) 往数组的前端添加元素 pop() 从数组的末尾删除元素,并返回 shift() 从数组的前端删除元素,并返回 sort() 数组排序(默认按照ASCII值排序),可以传递一个function参数 slice() 复制数组，并返回 splice() 剪切数组元素，并返回 concat() 拼接数组,返回一个数组 join() 按照param拼接数组,返回字符串 reverse() 数组反转 (也可以反转字符串) indexOf() 返回匹配的项,并返回索引,找不到返回-1 lastIndexOf() 返回匹配的项,并返回索引,找不到返回-1 find() 找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined findIndex() 找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1 forEach() 遍历数组 filter() 对数组的每一项执行指定函数，返回该函数会返回true的项组成的数组 map() 对数组的每一项执行指定函数，返回该函数调用结果组成的数组 some() 对数组的每一项执行指定函数，如果每一项都返回true则返回该数组 reduce() 迭代方法 fill() 用一个固定值填充一个数组中从起始索引到终止索引内的全部元素 entries() 返回一个迭代器 ps 数组中一些方法会改变原有数组的排列 push、unshift、pop、shift、splice、sort、reverse、fill 会返回的一个数组或者期望值的方法 sort、reverse、splice、slice、concat、join、indexOf、lastIndexOf、find、findIndex 会涉及到遍历数组的方法 forEach、filter、find、findIndex、some、map、reduce examplereverse 12345678910var str = "hello world";console.log(str.split("").reverse().join(""));var arr = [1,2,3];console.log(arr.reverse());for(var start=0,end=arr.length-1;start&lt;end;start++,end--)&#123; arr[start] ^= arr[end]; arr[end] ^= arr[end]; arr[start] ^= arr[end];&#125; sort 1234567891011121314151617181920212223242526272829var arr = [1,5,4,3,6,8,16,11];arr.sort();// sort 默认排序使用ASCII值比较console.log(arr); // [1,11,16,3,4,5,6,8];// 字符串之间的比较console.log('2' &gt; '199'); // true 一个道理// 怎么样完成数字大小的排序function compare(a,b)&#123; // a &lt; b &lt;==&gt; a-b&lt;0 return a -b;&#125;;// 完成正常排序需要 通过回调函数完成arr.sort(compare);arr.sort(function(a,b)&#123; // return a-b; // 升序 // return b-a; // 降序&#125;);function sortArr(arr) &#123; var entries = arr.entries(),temp; // while(temp = entries.next().value)&#123; // temp[1].sort((a ,b) =&gt; a - b); // &#125; for(var e of entries)e[1].sort((a ,b) =&gt; a - b); return arr;&#125;var arr = [[1,34],[456,2,3,44,234],[4567,1,4,5,6],[34,78,23,1]];sortArr(arr);// ### 元素重排序 数组升维降维 123456789101112131415161718192021222324252627282930var arr = [1,2,3,4,5,6];function chunk(arr, len)&#123; var temp = []; var index = 0; while(arr[index])&#123; temp.push(arr.slice(index, index+=len)); &#125; return temp;&#125;function chunk(array, size)&#123; if(!Array.isArray(array))&#123; return []; &#125; size = size || 1; var index = 0, resIndex = 0, length = array === null ? 0 : array.length, resLen = Math.ceil(length / ( size|0)); result = Array(resLen); while(index &lt; resLen)&#123; result[index++] = array.slice(resIndex, resIndex+=size); &#125; return result;&#125;console.log(chunk(arr,2));var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123; return a.concat(b);&#125;);console.log(flattened); // [0, 1, 2, 3, 4, 5] indexOf 123456789101112var arr = [1,2,3];console.log(arr.indexOf(2)); // 1// 同样indexOf 也有去重的作用var arr = [1,1,2,2,3,3];var foo = [];for(var i=0;i&lt;arr.length;i++)&#123; if(foo.indexOf(arr[i]) != -1)&#123; foo.push(arr[i]); &#125;;&#125;;console.log(foo); // [1,2,3] filter 1234567891011121314151617181920212223242526/* filter(item,index,array) item 遍历的当前元素 index 遍历的当前元素索引 array 当前所遍历的数组 做为数组的高级方法filter的过滤作用有很多的用处*/var arr = [1,2,3,4,5,6];// 返回满足条件的项 这里返回了偶数var foo = arr.filter(item=&gt; item %2 === 0)console.log(foo); // [2,4,6]// 数组去重arr.filter(function(item,index,array)&#123; //检索当前的索引是不是唯一 indexOf总返回第一个元素 后续的重复元素位置与 indexOf 返回的位置不相等 return array.indexOf(item) === index; //反过来思考 查看是否重复 返回-1的留下 return array.indexOf(item,index+1) == -1;&#125;);// 保留非空的非undefinedvar arr = [1,,2,3,,4,undefined,5];var foo = arr.filter(function(item)&#123; return item &amp;&amp; item.toString().trim() &amp;&amp; typeof item != 'undefined';&#125;); find 12345678910111213141516171819202122/* find(fn) findIndex(fn) fn(item,index,array)*/ var arr = [&#123;name:'xq'&#125;,&#123;name:'vk'&#125;,&#123;name:'afei'&#125;];var obj = arr.find(function(x)&#123;return x.name == 'xq'&#125;));var idx = arr.findIndex(function(x)&#123;return x.name == 'xq'&#125;));console.log(obj); // &#123;name: 'xq'&#125;console.log(idx); // 0// 查看是不是质数function isPrime(element, index, array) &#123; var start = 2; while (start &lt;= Math.sqrt(element)) &#123; if (element % start++ &lt; 1) &#123; return false; &#125; &#125; return element &gt; 1;&#125;console.log([4, 5, 8, 12].find(isPrime)); // 5 map 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数 map(fn); fn(item,index,array);*/// 格式化时间 function formatTime(date) &#123; var year = date.getFullYear(), month = date.getMonth() + 1, day = date.getDate(), hour = date.getHours(), minute = date.getMinutes(), second = date.getSeconds(); return [year, month, day].map(formatNumber).join('/') + ' ' + [hour, minute, second].map(formatNumber).join(':')&#125;function formatNumber(n) &#123; n = n.toString() return n[1] ? n : '0' + n&#125;;// 获取字符串的ASCII值var str = 'I love you';[].map.call(str,function(n)&#123; return n.charCodeAt();&#125;);// 遍历元素的属性var inputDoms = document.getElementsByTagName('input');[].map.call(inputDoms,function(val)&#123; return val.value;&#125;);// 反转字符串var str = 'hello xq';[].map.call(str,function(x)&#123; return x;&#125;).reverse().join('');// 类似的数字操作var arr = [10,21,32,4,2];var foo = arr.map(function(x)&#123; return x % 10;&#125;);console.log(foo); // 0, 1, 2, 4, 2// 问题["1", "2", "3"].map(parseInt);// 可能觉的会是[1, 2, 3]// 但实际的结果是 [1, NaN, NaN]// parseInt有两个参数默认 parseInt做为回调函数传入map会给其默认传递三个参数 会把索引值当成进制使用// 改进['1', '2', '3'].map(Number);// [1, 2, 3] reduce 123456789101112131415161718192021222324// 迭代求和var arr = [1,2,3,4];var sum = 0;for(var k in arr)&#123; sum += arr[k];&#125;var sum1 = arr.reduce((a, b) =&gt; a + b);// 统计字符出现次数var str = "aabbcc";var count = str.split("").reduce((a, b) =&gt; ( a[b]++ || (a[b]=1),a ), &#123;&#125;);console.log(count);// 判断 a出现的次数var count = str.split("a").length - 1;// 判断数组中某一个元素出现次数var count = (arr, value) =&gt; arr.reduce((a, b) =&gt; b === value ? a + 1 : a + 0, 0);// 转换中文数字var num = 123450;function convert(num)&#123; var arr = ["零", "一", "二", "三", "四", "五", "六", "七", "八", "九"]; return num.toString().split("").reduce((a, b) =&gt; ( a + arr[b] ), "");&#125;console.log(convert(num));]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String Number Boolean]]></title>
    <url>%2F2018%2F02%2F08%2FJavascript%2FString-Number-Boolean%2F</url>
    <content type="text"><![CDATA[为了便于操作，javascript 提供了三个基本包装类型。在使用中不需要声明再去调用不同的方法。 Package Class看一个 example 12var str = "String";str.substring(2); str 固然是一个字符串基本类型，那怎么可以去调用 substring 这个方法的。其实是这样的 1234var str = "String";var temp = new String(str);temp.substring(2);temp = null; 经过这样子的处理之后基本类型变得和对象一样了。其它的 Number、 Boolean 同样适用。基本包装类型的生命周期，当调用对象的方法时，就会自动创建一个相应的引用实例，然后执行结束后又会马上销毁的。这也就意为不能为基本类型去添加属性。 12345678910var str = "xq";str.color = "red";console.log(str.color); // undefined// 实际上var str = "xq";var temp = new String(str);temp.color = 'red';temp = null;console.log(str.color); // undefined 类型检测 123456var str = "String";var object = new String("String");console.log(typeof str); // stringconsole.log(typeof object); // objectconsole.log(str instanceof String); // falseconsole.log(object instanceof String); // true 手动创建一个基本包装类类型为 object 。不推荐这么去做，会傻傻分不清楚。搞清楚了基本包装类那么来看一下基本包装类底下的常用方法有哪些。 String 方法 描述 chaAt(n) 返回指定索引位置的字符 charCodeAt(n) 以Unicode编码形式返回指定索引位置的字符 fromCharCode(ascii) 返回ASCII对应的字符 indexOf(str, index) 从左往右查找字符str是否在字符串中,找到返回索引,找不到返回-1 lastIndexOf(str, index) 从右往左查找字符str是否在字符串中,找到返回索引,找不到返回-1 substring(n,m) 返回区间[n,m]之间的字符串,不包括m索引位 slice(n,m) 返回区间[n,m]之间的字符串,不包括m索引位 substr(n,m) 返回n索引之后的m个字符 toLowerCase() 全部转换成小写 toUpperCase() 全部转换成大写 split(pattern) 按照pattern匹配来切分原始字符串 repalce(str, repalceStr) 被用来在正则表达式和字符串直接比较，然后用新的子串来替换被匹配的子串。 trim() 从字符串的开始和结尾去除空格 trimLeft() 去除字符串左边空格 trimRight() 去除字符串右边空格 match(pattern) 使用正则表达式与字符串相比较。 新增语法 方法 描述 includes(str) 判断一个字符串里是否包含其他字符串 endsWith(search, index) 判断一个字符串的结尾是否包含其他字符串中的字符，可以调整位置 startsWith(search, index) 判断一个字符串的起始是否包含其他字符串中的字符，可以调整位置 repeat(n) 返回指定重复次数的由元素组成的字符串 ps： 需要注意一下substring和slice 参数的正负 substring() n,m 如果小于0 就变成0。 n&gt;m ，n,m 交换位置 slice() n,m 如果小于0 就变成n/m+str.length。n&gt;m ，结果null substr 在IE传递负值会返回原始字符串 str[index]、charAt(index) 效果一样的 但是str[index] 在IE会返回undefined Number 属性 属 性 描述 MAX_VALUE 表示最大数 MIN_VALUE 表示最小值 NaN 非数值 NEGATIVE_INFINITY 负无穷大，溢出返回该值 POSITIVE_INFINITY 无穷大，溢出返回该值 方法 方 法 描述 toString() 将数值转化为字符串，并且可以转换进制 toFixed() 将数字保留小数点后指定位数并转化为字符串 toExponential(param) 将数字以指数形式表示，保留小数点后指定位数并转化为字符串 toPrecision(param) 指数形式或点形式表述数，保留小数点后面指定位数并转化为字符串 isNaN(param) ES6 判断到底是不是NaN 区别isNaN方法 toLocaleString(param) 返回一个字符串 pactice这里挑几个有意思的练习一下，因为上述方法需要结合很多不同的内容场景使用。 123456789101112131415161718192021222324252627282930313233343536373839// 随机数function randomNumber(start, end)&#123; return Math.floor(Math.random() * (end - start + 1) + start);&#125;// rgbfunction randomRgb()&#123; return 'rgb(' + randomNumber(255) + ',' + randomNumber(255) + ',' + randomNumber(255) + ')';&#125;// hexfunction randomHex()&#123; return '#' + Math.random().toString(16).substring(2).substr(0, 6);&#125;function randomHex()&#123; var color = '#'; for (var i = 0; i &lt; 6; i++) &#123; color += '0123456789abcdef'[randomNumber(15)]; &#125; return color;&#125;// 重复str.repeat(n);// 替换var str = 'xq很帅,xq很帅,xq很帅';function replaceStr(str, search, rep)&#123; var temp = str.slice(); while(temp.includes(search))&#123; temp = temp.replace(search, rep); &#125; // while(temp.indexOf(search) != -1)&#123; // temp = temp.replace(search, rep); // &#125; return temp;&#125; 1234567891011121314151617181920212223242526272829var arr = [7,2,3,4,5];function getMinNum(arr)&#123; var max = Number.MAX_VALUE; // 最大数 var index = -1; for(var i=0;i&lt;arr.length;i++)&#123; if(max &gt; arr[i])&#123; max = arr[i]; index = i; &#125; &#125; return index;&#125;// toLocaleStringvar number = 123456.12；// 逗号隔开console.log(number.toLocaleString())；// 123,456.123// 中文console.log(number.toLocaleString('zh-Hans-CN-u-nu-hanidec'))；// 一二三,四五六.一二三// 货币console.log(number.toLocaleString('en', &#123; style: 'currency', currency: 'USD'&#125;));// $ 123,456.12console.log(number.toLocaleString('en-IN', &#123; style: 'currency', currency: 'EUR'&#125;));// € 123,456.12console.log(number.toLocaleString('en-IN', &#123; style: 'currency', currency: 'CNY'&#125;));// ￥123,456.12]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[callBack]]></title>
    <url>%2F2018%2F02%2F07%2FJavascript%2FcallBack%2F</url>
    <content type="text"><![CDATA[callBack的存在在javascript中随处可见在没有 promise 的年代各种流行的框架随处可见包括原生DOM事件，jQuery中通过callBack可以做很多很多事情。 callBack?首先看一下 google 与 百度 的释义 A callback is a function that is passed as an argument to another function and is executed after its parent function has completed. 译：回调是一个函数，作为参数传递给另一个函数，并在其父函数完成后执行。 通过 函数指针 调用的函数。如果你把函数的 指针（地址）作为 参数传递 给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。 看一下官方的说法之后并且对语言特性的理解，其实就很容易明白两句话中的一个点 参数传递。如果对c或者c++学习的人可能就明白下面百度的释义。毕竟 javascript 是 c++ 开发出来的。 先来看例子 123456$("#box").click(function()&#123; // statement&#125;);obj.addEventListener('click', function()&#123; // statement&#125;) 在 javascript 中很多地方都可以看到这样的执行方式。它们有一个名字叫做回调函数（callBack）。 为什么出现callBack首先说一下浏览器内部包含 js解析引擎 渲染引擎 http请求 event事件 webAPI ，常驻线程前三个。 js开始设计的时候是一个单线程的，这就省了很多复杂的操作比如线程间的通信，所以浏览器在处理js代码的时候需要一件件去做，产生列队（这里不讨论浏览器怎么去处理事件列队的）。经常见到的场景就是用户发起一个请求，等到资源加载完毕执行一些用户的操作，请求的过程大多是一个异步的过程，试想一下如果在发起请求的时候浏览器把当前页面锁住了，是不是很蛋疼？ 123456// 异步请求 success执行 statement语句$.ajax(&#123; success: function()&#123; // statement &#125; &#125;) 也就是说有两个任务A、B在执行的时候需要先执行A等到一定的结果之后在去执行B的时候就必须使用这样的方式 example 12345678910function A()&#123; console.log("hello"); if(expression)&#123; B(); &#125;;&#125;function B()&#123; console.log("world");&#125;A(); 那么问题来了如果A任务完成之后，我们的需求并不是执行B这个任务的时候想换成任务C是不是就需要在去添加一个C任务，等待我们去选择。如果这样子的话那真的要累死了。因为你永远不知道下一次变化是什么。打一个不恰当的比方就好比你女票突然生气但是很多男孩子基本都不知道怎么了，基本都是临场应变，如果是一个有经验的人可能有一些预备措施，看似好像这个男孩子很聪明，如果下次女孩子生气你没有预料到不就惨了。反映到程序上就是，开发者不需要管任务A执行完成，B任务是什么。 example 12345678function girl(boy)&#123; if(expression)&#123; （boy &amp;&amp; typeof boy === 'function'）&amp;&amp; boy(); &#125;&#125;girl(function()&#123; // 想干嘛干嘛我都接住&#125;) 讲函数做为参数传递是很多语言都具有的能力，js中函数也是一个数据类型所以理所应当可以传递只是区别与其它的数据类型的地方在于函数可以执行 问题 事物都有两面性，当然有好处就有坏处。 example 1234567891011121314a(function (resultA) &#123; b(resultA, function (resultB) &#123; c(resultB, function (resultC) &#123; d(resultC, function (resultD) &#123; e(resultD, function (resultE) &#123; f(resultE, function (resultF) &#123; // 子子孙孙无穷尽也 console.log(resultF); &#125;); &#125;); &#125;); &#125;); &#125;);&#125;); 现在有很多任务a、b、c、d、e、f……都要依赖上一个任务的结果做为执行的条件。那么就进入了一个无限去嵌套的过程，现在看似很轻松很容易读，但是加上一系列的逻辑判断之后，面目全非……。经过很多年的发展 jQuery 以及很多的框架都在努力去解决这个问题，于是 promise 诞生了。暂且不谈。只是想告诉大家回调虽好但是在使用的过程中也要注意避免出现这样的代码，首先不便阅读，在者就不易维护与修改。 回调的好处可以简单的总结一下了 更加的灵活去处理需求 DOM事件处理监听 setTimeout与setInterval中调用得到结果并且返回，setTimeout延迟0的挂起作用 callBack是一个可以被执行一次或者多次，看情况例如Array中的迭代方法]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scope]]></title>
    <url>%2F2018%2F02%2F07%2FJavascript%2Fscope%2F</url>
    <content type="text"><![CDATA[Javascript的执行环境（ execution context 执行上下文）依赖于浏览器，每一个变量，函数都会有自己的执行环境，在web浏览器中执行环境 window 对象。即全局创建的变量函数都做为 window 对象的属性和方法。需要强调的是 function 也是一个独立的执行环境。程序执行依次进入 call stack 进栈执行，执行到函数进入函数内部执行上下文，也就是进入执行环境会创建变量对象的作用域链（ scope chain ）按这种机制有序的访问所有的变量与函数。所以学习 Javascript 执行机制是非常必要的。 scope 我们习惯性的把script的大环境称之为全局，单独的函数，块级作用域称之为局部。所谓相对绝对都是依靠一个参照点。 hosit首先来了解一下 js 在浏览器中执行所经过的两个阶段 词法分析 与 执行阶段 词法分析也可以想成其它语言的编译阶段。 12345678var num = 10;num += 1;console.log(num);// 当浏览器的js解析引擎工作会把上述代码变成 比较简单var num;num = 10;num = num + 1;console.log(num); 再来看一个 123456789console.log(num); // undefinedvar num = 10;console.log(num); // 10// js解析过程var num;console.log(num);num = 10;console.log(num); 这里有一个概念 Hoist（ 提升），词法分析阶段所有定义过程譬如定义变量，定义函数都会被提升到当前context 的顶端，在执行阶段在依次执行譬如赋值、运算、函数调用。但是函数是一个独立的作用域进入函数的 context 依然是进行这两个阶段。 12345678910111213141516var num = 10;console.log(foo); // fooconsole.log(fn); // undefinedvar fn = function()&#123; alert(1) &#125;;function foo()&#123;&#125;；// js解析过程// 词法分析var num;var fn;function foo()&#123;&#125;// 执行num = 10;console.log(foo);console.log(fn);fn = function()&#123; alert(1) &#125;; 需要注意的是函数的定义方式与表达式的写法在运行的过程中是不一样的。定义变量初始化赋值是两个过程。否则在调用的过程中可能会出现错误。 letlet 不存在 hosit 现象更好的规避了可能出现访问失败的问题，更好按照一种逻辑去执行。在这里提一下 scope chain 作用域链。执行环境的不同，所以当程序访问不同的变量与函数需要一定的规则去辨别 1234567// eg1var num = 10;function fn()&#123; console.log(num); num = num + 10;&#125;fn(); 123456789101112131415161718192021// eg2var num = 10;function fn()&#123; console.log(num); var num = 20; console.log(num);&#125;fn()// js解析过程// 词法分析var num；function fn()&#123;&#125;// 执行num = 10;fn();// fn context 词法分析fn()&#123; var num;&#125;// 执行 上边两个情况做一个简单的对比 eg1 fn内部可以访问到外部的 num 变量顺着作用域链，eg2 fn内部同样可以访问到外部的 num 但是结果不同，试想一下如果外部与自己具有相同变量名称时，就会出现一个访问顺序的问题，当fn在搜索 num 这个变量时当前自己的 scope 不存在就会沿着 chain 去继续往上一级 scope 寻找，如果自己有就不会在顺着 chain 查找。 可能有人开始有这样的想法。那如果我想外部访问到函数内部的变量呢？ 1234567var num = 10function fn()&#123; var num = 20; return num;&#125;console.log(num); // 10console.log(fn(num)); // 20 可以通过return返回 这个并没有延长作用域链 return num同样也会去沿着作用域链去去查找 fn中的num生命周期会随着函数的结束而消失 js中垃圾回收 block scopejs中之前没有明确的块级作用域 1234567891011121314for(var i=0;i&lt;4;i++)&#123;&#125;console.log(i); // 4if(true)&#123; var num = 10; let block1 = 20;&#125;console.log(num); // 10console.log(block1); // not defined&#123; let block2 = 30;&#125;console.log(block2); // not defined let const 会把被大括号限制范围，也就是说外界无法通过大括号访问内部的用let const声明的变量。 特殊的 12345fn(); // TypeError: a is not a functionif(true) function fn()&#123; console.log(1) &#125;else function fn()&#123; console.log(2) &#125; if 会将函数定义转变为表达式去处理 123var fn;fn();if()...else...]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[function 函数]]></title>
    <url>%2F2018%2F02%2F06%2FJavascript%2Ffunction%2F</url>
    <content type="text"><![CDATA[Function javascript中的函数被称为一等公民（First-class object）。函数是一种数据类型、可以当作构造函数、可以当作参数传递、可以赋值成为变量、可以添加属性、可以当作对象、可以当作返回值、可以存储、更加可以去执行。 定义函数的定义分为三种 123456789101112// 1. 定义式 -- 有名function fnName(arg1, arg2, ..., args)&#123; // statement&#125;// 2. 表达式 -- 匿名var fnName = function(arg1, arg2, ..., args)&#123; // statement&#125;// 3. new 关键字实例化创建对象 -- 很少用 var fnName = new Function(statement); 通过 () 运算符执行调用函数运行 函数理解刚刚接触函数个人觉得需要认识到几个点 函数是一种特殊的数据类型 函数是一个独立的作用域 函数可以单独执行或者返回具体的结果 函数是单纯的个体 分别来看一下，第一条不解释了 独立作用域 1234567var a = 10function foo()&#123; // foo 中的a在函数外部是访问不到的 前提是通过了var let const 定义的变量 // a相对于script是一个局部的变量 相对于foo是一个全局 理解全局局部的同时希望加上参考范围 不要混淆 var a = 20;&#125;foo(); 单独执行、返回结果 1234567891011121314function sum(a, b)&#123; console.log(a + b);&#125;sum(1, 2); // 3function add(a, b)&#123; return a + b;&#125;var result = add(1, 2); // 3/* 同样都可以返回3 但是前者单纯的去执行 后者将结果返回并且赋值给变量result供其它去使用 也就是说函数可以有返回值也可以没有返回值 javascript中函数默认返回undefined*/ 单纯 123456789101112131415161718192021// 所谓的单纯 不会过度的依赖一些变化 导致修改的时候会让复杂度不断提高// 1var minAge = 20;var check = function(age)&#123; return age &gt; mixAge;&#125;// 2var checkAge = function(age)&#123; var minAge = 20; return age &gt; minAge;&#125;/* 前者会依赖minAge影响最终的结果， 换句话说取决于另外一个程序状态 后者因为minAge状态不会改变，结果不会受其它程序状态的影响 有的时候我们可能为了复用一段代码而去封装成一个函数，但是还是多思考一下 因为当你有一天去修改的时候可能已经对内在的复杂度……懂得吧 所以尽可能做为一种功能去使用函数*/ 参数的理解 函数中可以传递参数，javascript中传递参数不用去在乎是什么数据类型 1234567891011121314151617/* 函数定义所写的参数称之为形式参数 调用时传递的参数称之为实际参数 1. 形参个数 &gt; 实参个数 少的undefined代替 2. 实参个数 &gt; 形参个数 多的忽略 3. 不定参arguments 用于接受传递的所有参数*/function fn（a, b）&#123;&#125;fn(1); // 少写的b被undefined代替 如果有运算就会出问题fn(1, 2, 3); // 多写的3 会被忽略function foo()&#123; var args = arguments; console.log(args); console.log(args.length == foo.length);&#125;fn(1, 2); // 打印1, 2 打印false foo.length 返回函数的形式参数的个数也就是定义的时候有多少参数。可以通过这个性质进行判断参数列表是否对应 123456789function foo(a, b)&#123; if(foo.length == arguments.length) &#123; // statement1 &#125;else&#123; // statement2 &#125;&#125;// foo.length 可能为 arguments.callee （返回当前函数 可以想成就近原则）// arguments.callee 是一个避免函数引用错误的一个很好的做法 但是在'use strict'下callee是禁止使用的 在JavaScript中没有函数重载的概念，但是可以通过参数列表 arguments 来模拟重载效果，仅仅是类似的效果 12345678function foo()&#123; var args = arguments; if(args.length === 1)&#123; return args[0]; &#125;else if(args.length === 2)&#123; return args[0] + args[1]; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[控制语句]]></title>
    <url>%2F2018%2F02%2F05%2FJavascript%2FControlling%20Execution%2F</url>
    <content type="text"><![CDATA[Controlling Execution 所有生物都会去控制自己的行为。程序也必须在执行的过程中控制它的过程。程序在执行的时候要么在顺序执行要么跳转。因此选择合适的控制语句来帮助程序做出正确的判断。控制语句包含了 判断 、循环遍历 一系列简单的命令。 流程控制if 在逻辑运算中已经使用到了 if 语句 1234567891011121314151617/* if( boolean ) statement1 else statement2 大括号可以省略不写 看情况 boolean的含义不仅仅是简单的true or false false 0 NaN undefined null 空字符"" 在判断中都代表假*/if(10 &gt; 5) alert("max:" + 10);else alert("min:" + 5)if(condition1) // statement1else if(condition2) // statement2else // statement3 switchswitch 与 if 有点相似 12345678910111213141516/* 注意点： 1. 每一条case加break，除非是要合并结果可以不加 2. value不会发生隐式转换*/switch(表达式)&#123; case value1: statement1 break; case value2: statement2 break; case value3: statement3 break; &#125; 循环 所谓循环就是多次重复执行某些类似的操作。这个操作一般不是完全一样的操作，而是类似的操作。 for12345678910111213141516171819202122232425262728293031for（var i = 0; i &lt; 3; i++）&#123; // statement&#125;;var i = 0;for（; i &lt; 3; i++）&#123; // statement&#125;;var i;for(i = 0; i &lt; 3; i++)&#123; // statement&#125;var i = 0;for(; i &lt; 3; i+=1)&#123; // statement&#125;var i = 0;for(; i &lt; 3; )&#123; i+=1 // statement&#125;// 和上一种有区别for(;;)&#123; // statement 死循环&#125;// 在循环体外 访问console.log(i) 是可以找到的 循环的写法有很多种，同样可以省略大括号。大家对循环的认识可能只是简单的遍历某一个内容，其实循环的使用是很广泛的是一类问题处理的总结。需要细细的去体会 while while是循环的一种变体 123456789101112/* while(expression)&#123; // statement &#125; expression 条件为假终止循环体 条件为假的情况在if中已经提到 类似的场景下 满足while的这个特性都可以使用while循环*/var i = 0;while(i&lt;3)&#123; // statement i++; // i+=1;&#125; do while 后测试语句，优先执行statement语句后进行判断 1234do&#123; // statement&#125;while(expression);// 至少会执行一次statement 如果有这种情况使用do...while的情况会比较多 for in 用于枚举对象属性、数组每一项 123456789101112// 或者是数组 虽然不推荐用来迭代数组但是有效果 这个后面再看for(var k in obj)&#123; // statement k 属性 console.log(k +'---'+ obj[k]);&#125;// for in 可以结合if语句使用 让一个语句更加清晰 只是这种写法并没有被ECMA视为规范// 但是在平时的书写中还是可以让程序很清晰 便于阅读var arr = [1,2,3,4];for(var k in arr) if(k &gt; 1)&#123; console.log(arr[k]); // 2, 3, 4&#125; for of 可迭代对象（泛指）IE对此迭代不兼容 12345678910for (variable of iterable) &#123; //statements&#125;var iterable = [1,2,3];for(var value of iterable)&#123; console.log(value); // 1, 2, 3&#125;// 同样 for of也可以结合iffor(var value of iterable) if (value &gt; 1) console.log(value); break &amp; continuebreak 用于终止当前循环，并且跳出整个循环体 continue 用于结束当前语句，继续执行下一次循环迭代。 都是可选语句。 last虽然循环看起来只是重复执行一些类似的操作而已，但它其实是计算机程序解决问题的一种基本思维方式，计算机程序可以发挥出强大的能力，重复的工作都可以使用这种思想去解决，或者同一类相似的任务。更加应该明白的是for循环的执行过程以及与控制语句break contiune 的结合。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作符]]></title>
    <url>%2F2018%2F01%2F04%2FJavascript%2FOperators%2F</url>
    <content type="text"><![CDATA[Operators javascript中的操作符 算术运算符 赋值运算符 关系运算符 逻辑运算符 位运算符 逗号运算符 这里我们着重看一下关系运算符 逻辑运算符 位运算符 逗号运算符 关系运算符js的关系操作符需要 注意 几个点 如果比较的是数值, 则执行数值比较 1234567var str = "10";var num = 11;console.log(str &lt; num); // truevar str = "100";var num = 2;console.log(str &gt; num); // true 如果比较的是两个字符, 则比较两个字符对应的编码ASCII值 123456var str = "100";var num = "2";console.log(str &gt; num); // false 比较第一位 如果相等比较第二位var result = "mike" &lt; "haha";console.log(result); // false 如果比较的是布尔值, 则先将其转换为数值 123var boolean = true; // Number(true) 为 1var num = 2;console.log(boolean &lt; num); // true 来看几个特殊的 1234567var result = "x" &lt; 10; // falsevar result = undefined == null; // truevar result = undefined === null;// falsevar result = null == 0; // falsevar result = null &gt;= 0; // truevar result = NaN == NaN; // falsevar result = [] == ![]; // true “x”字符不能被合理的转化成数字即Number(“x”) = NaN, 然而NaN和任何操作数比较都返回false, 毕竟NaN == NaN都返回false, 我连我自己都不认识 undefined与null, 两个都表示无, 转成数值undefined为NaN, null为0 当进行两个等号判断返回true, 三个等号返回false, 但是在某些特定情况下, 例如定义变量未初始化, 对象扩展属性未赋值, 函数默认返回undefined在这些情况下null是无法替代的, 因为null会被转换成0可能造成运算错误.这个特性记住就好了. null与0直接判断==操作时返回false, 惊不惊喜意不意外, null的数据类型是object, 如果比较的是对象, 则调用valueOf()方法或者toLocaleString()方法返回的结果去比较, 但是null很特殊没有这些方法, null做为原型链的尽头,所以null == 0不会做特殊处理 返回false. null &gt;= 0比较时这个问题在ECMA规定中&gt;,=存在运算优先级的问题被分为了两部分,需要注意的是并不是&gt;和=判断的结合,这里只是当 null &gt;= 0判断是会转换成Number(null) &gt;= 0, 记住就好. 在关系判断中会存在很多的数据类型的转化, 抓住本质才好哟. 1234console.log(1 + 1 + "1"); // 111console.log(1 + + "1" + 1); // 3// 相当于console.log(1 + (+"1") + 1); // 会被隐式转换成number 逻辑运算符&amp;&amp; and || 1234567var num = 20;if( 10&lt; num &lt; 19)&#123; console.log(1);&#125;else&#123; console.log(2);&#125;// 1 因为 10 &lt; 20 &lt; 19 是依次从左向右执行 true &lt; 19 true被转换成1 &lt; 19 返回true 打印1 这也就是为什么必须要有 &amp;&amp; 操作符 应当改写成 num &gt; 10 &amp;&amp; num &lt; 19 并且操作符其它用法 123456789function fn()&#123; console.log(1);&#125;;(2&gt;1) &amp;&amp; fn(); // 1var num = 10 &amp;&amp; 5; // 5// &amp;&amp; 碰到假才停止 只要前后表达式都是真就一直向后运算 那么|| 与之相反 碰到真就停止 也就是常说的惰性赋值var num = 0 || 1; // 1 当一个表达式中并且, 或者同时出现, 并且优先级高于或者 适当的添加括号去进行合理的判断 位运算符 一个字节的大小 8个二进制位, 有符号的整数占4个字节 32个二进制位, 其中31位用于表示整数的值, 最高位为符号位 在学习位运算符首先我们需要清楚计算机存储数字的是怎么样的表现形式. 位运算符包括 右移(&gt;&gt;)、 左移(&lt;&lt;)、 无符号右移(&gt;&gt;&gt;)、 按位或(|)、 按位与(&amp;)、 按位异或(^)、按位非(~) 右移、左移 ​ ​ 12console.log(8 &lt;&lt; 1); // 16 10000 = 2^4*1 + 2^3*0 + 2^2*0 + 2^1*0 + 2^0*0 = 16console.log(8 &gt;&gt; 2); // 2 00010 = 2^1*1 + 2^0*0 简单记左移乘以2, 右移除以2, 无符号右移和右移的区别. 对于正数没有什么区别, 因为每次移动都会在最高位补符号位, 负数是正数的二进制补码直接右移之后会被当成正数的二进制, 会产生很大的误差. 按位与、按位或 ​ 12console.log(10 &amp; 15); // 10console.log(10 | 15); // 15 原理和逻辑运算符中一致，&amp;运算同1返回1， |运算同0返回0， 在哪里使用？其实当我们想要返回一个数字的有效位就要用到&amp;运算了，可以尝试写一个进制转换的函数。运用一下, 另外在对一个数字取整时可以使用位或0 123console.log(Math.floor(6.19));console.log(parseInt(6.19));console.log(6.19 | 0); // 6 因为二进制是没有小数的 ​ 按位异或 1console.log(10 ^ 7); // 13 看图不做解释了， 这里说一下按位异或的用法。当对一个数字连续位异或同一个数字的时候会返回原来的数字也就是说, 可以用来交换两个变量的值，或者toggle一个变量，或者检测两个数正负是否一致 12345678910111213141516171819console.log(10 ^ 7 ^ 7); // 10var a = 10;var b = 20;a = a ^ b;b = a ^ b; // a ^ b ^ b = aa = a ^ b; // a ^ a ^ b = b// toggle变量if (x === a) &#123; x = b&#125; else if (x === b) &#123; x = a&#125;x = a ^ b ^ x;// 检测正负if ((x ^ y) &gt;= 0) &#123; // ...&#125; 按位非 把二进制的每一位取反就是 ~ ,一个整数的负数逐位取反加一. 这里就不介绍二进制补码的运算原理了可以自行查阅资料. 12345var num = 8;console.log(~num+1); // -8// 取整一个整数console.log(~~8.5); // 8 逗号运算符123var a = 10, b = 20, c = 30;var num = (1,2,3);var arr = ([1,2],[3,4]); 逗号操作符可以用来声明多个变量，用于赋值的时候总是返回表达式最后一项。利用好这个特性可以很方便我们简化代码。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3.6字符串方法]]></title>
    <url>%2F2018%2F01%2F01%2FPython%2FPython3-6%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python3.6字符串方法 序号 方法名 解释 运行 结果 1 capitalize() 将字符串的第一个字符转换为大写 ‘abc’.capitalize() ‘Abc’ 2 casefold() 将字符变成小写，但是可以处理非ASCII码，如将ß变成ss,这个是lower()做不到的 ‘abcdßef’.casefold() ‘abcdssef’ 3 center(width[, fillchar]) 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。 ‘abc’.center(8,’-‘) ‘–abc—‘ 4 count(sub[, start[, end]]) 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 ‘aaa’.count(‘a’) 3 5 encode(encoding=”utf-8”, errors=”strict”) 以encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’ ‘abc帅帅abc’.encode(encoding=’utf-8’,errors=’igonre’) b’abc\xe5\xb8\x85\xe5\xb8\x85abc’ 6 bytes.decode(encoding=”utf-8”, errors=”strict”) Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。 st = ‘abc帅帅abc’.encode(encoding=’utf-8’,errors=’igonre’) st.decode(encoding=’utf-8’) ‘abc帅帅abc’ 7 endswith(suffix[, start[, end]]) 检查字符串是否以 suffix 结束，如果start 或者 end 指定则检查指定的范围内是否以 suffix 结束，如果是，返回 True,否则返回 False ‘abc’.endswith(‘c’) True 8 expandtabs(tabsize=8) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 ‘\tabc’.expandtabs() ‘ abc’ 9 find(sub[, start[, end]]) 检测 str 是否包含在字符串中 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1 ‘abc’.find(‘a’) 0 10 format(*args,**kwargs) 字符串格式化，使用时字符串中需要包含{} ‘帅帅 {}’.format(‘Python’) ‘帅帅 Python’ 11 format_map(mapping) 类似 str.format(*args, **kwargs) ，不同的是 mapping 是一个字典对象 ‘My name is {name},i am {age} old’.format_map({‘name’:’付帅帅’, ‘age’:18}) ‘My name is 付帅帅,i am 18 old’ 12 index(sub[, start[, end]]) 跟find()方法一样，只不过如果str不在字符串中会报一个异常 ‘hello word!’.index(‘word’) 6 13 isalnum() 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False ‘123a12’.isalnum() True 14 isalpha() 如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False ‘abcd’.isalpha() True 15 isdecimal() 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false ‘12312’.isdecimal() True 16 isdigit() 如果字符串只包含数字则返回 True 否则返回 False.. ‘123’.isdigit() True 17 isidentifier() 判断字符串是否可为合法的标识符 ‘dobi 123’.isidentifier() False 18 islower() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False ‘Ab’.islower() False 19 isnumeric() 如果字符串中只包含数字字符，则返回 True，否则返回 False ‘Sjd2’.isnumeric() False 20 isprintable() 判断字符串的所有字符都是可打印字符或字符串为空 ‘handsomeFu 123’.isprintable() True 21 isspace() 如果字符串中只包含空格，则返回 True，否则返回 False. ‘ ‘.isspace() True 22 istitle() 如果字符串是标题化的(见 title())则返回 True，否则返回 False ‘handsomeFu Blog’.istitle() False 23 isupper() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False ‘handsomeFu’.isupper() False 24 join(iterable) 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 ‘-‘.join([‘2012’, ‘3’, ‘12’]) ‘2012-3-12’ 25 ljust(width[, fillchar]) 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格 ‘handsomeFu’.ljust(9, ‘^’) ‘handsomeFu^^’ 26 lower() 转换字符串中所有大写字符为小写. ‘ABcdEf’.lower() ‘abcdef’ 27 lstrip([chars]) 截掉字符串左边的空格 ‘ handsomeFu’.lstrip() ‘handsomeFu’ 28 maketrans(x[, y[, z]]) 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标 str.maketrans(‘abce’, ‘1234’) {97: 49, 98: 50, 99: 51, 101: 52} 29 partition(sep) 用指定的分隔字符串(参数sep)来分隔原字符串，返回一个包含三个元素的元组。 如是指定的分隔字符串(参数sep)在原字符串中存在，则返中的元组中前后两个元素分别为被分隔开的原字符串（不包括分隔字符串），中间元素为分隔字符中。 ‘handsome0219’.partition(‘h’) (‘’, ‘h’, ‘andsome0219’) 30 replace(old, new[, max]) 把将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次 ‘dog wow wow jiao’.replace(‘wow’, ‘wang’, 2) ‘dog wang wang jiao’ 31 rfind(sub[, start[, end]]) 类似于 find()函数，不过是从右边开始查找 ‘outer protective covering’.rfind(‘er’, 20, 21) -1 32 rindex(sub[, start[, end]]) 方法返回子字符串最后一次出现在字符串中的索引位置，该方法与[ rfind()] 方法一样，只不过如果子字符串不在字符串中会报一个异常。 ‘love python love python!’.rindex(‘python’) 17 33 rjust(width[, fillchar]) 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串 “this is string example….wow!!!”.rjust(50, ‘*’) ‘**this is string example….wow!!!’ 34 rpartition(sep) 从后往前查找，返回包含字符串中分隔符之前、分隔符、分隔符之后的子字符串的tuple；如果没找到分隔符，返回字符串和两个空字符串 “handsomeFu is very handsome”.rpartition(‘o’) (‘handsomeFu is very hands’, ‘o’, ‘me’) 35 rsplit(sep=None, maxsplit=-1) 通过指定分隔符对字符串进行分割并返回一个列表，默认分隔符为所有空字符，包括空格、换行(\n)、制表符(\t)等。类似于 [split()] 方法，只不过是从字符串最后面开始分割。 “this is a ipython3”.rsplit(‘i’,1) [‘this is a ‘, ‘python3’] 36 rstrip([chars]) 删除字符串字符串末尾的空格 “this is handsomeFu “ .rstrip() “this is handsomeFu111”.rstrip(“1”) “this is handsomeFu” “this is handsomeFu” 37 split(sep=None, maxsplit=-1) num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num 个子字符串 ‘123423664234’ .split(‘2’) [ ‘1’, ‘34’ , ‘3664’, ‘34’] splitlines([keepends]) 按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 ‘ab c\n\nde fg\rkl\r\n’.splitlines(); [‘ab c’, ‘’, ‘de fg’, ‘kl’] 39 startswith(prefix[, start[, end]]) 检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查 ‘mynameis’.startswith(‘na’,2,7) True strip([chars]) 在字符串上执行 lstrip()和 rstrip() ‘ abc ‘.strip() ‘abc’ 41 swapcase() 将字符串中大写转换为小写，小写转换为大写 “this is handsomeFu”.swapcase() THIS IS handsomeFu 42 title() 返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) ‘this is handsomeFu’.title() ‘This Is handsomeFu’ 43 translate(table) 根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中 ma = str.maketrans(‘abce’, ‘1234’) st = ‘abcdefgabcd’ st.translate(ma) ‘123d4fg123d’ 44 upper() 转换字符串中的小写字母为大写 “python”.upper() PYTHON 45 zfill(width) 返回长度为 width 的字符串，原字符串右对齐，前面填充0 ‘handsomeFu’.zfill(12) ‘00handsomeFu’]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3.6字符串方法]]></title>
    <url>%2F2018%2F01%2F01%2FPython3-6%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python3.6字符串方法 序号 方法名 解释 运行 结果 1 capitalize() 将字符串的第一个字符转换为大写 ‘abc’.capitalize() ‘Abc’ 2 casefold() 将字符变成小写，但是可以处理非ASCII码，如将ß变成ss,这个是lower()做不到的 ‘abcdßef’.casefold() ‘abcdssef’ 3 center(width[, fillchar]) 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。 ‘abc’.center(8,’-‘) ‘–abc—‘ 4 count(sub[, start[, end]]) 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 ‘aaa’.count(‘a’) 3 5 encode(encoding=”utf-8”, errors=”strict”) 以encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’ ‘abc帅帅abc’.encode(encoding=’utf-8’,errors=’igonre’) b’abc\xe5\xb8\x85\xe5\xb8\x85abc’ 6 bytes.decode(encoding=”utf-8”, errors=”strict”) Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。 st = ‘abc帅帅abc’.encode(encoding=’utf-8’,errors=’igonre’) st.decode(encoding=’utf-8’) ‘abc帅帅abc’ 7 endswith(suffix[, start[, end]]) 检查字符串是否以 suffix 结束，如果start 或者 end 指定则检查指定的范围内是否以 suffix 结束，如果是，返回 True,否则返回 False ‘abc’.endswith(‘c’) True 8 expandtabs(tabsize=8) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 ‘\tabc’.expandtabs() ‘ abc’ 9 find(sub[, start[, end]]) 检测 str 是否包含在字符串中 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1 ‘abc’.find(‘a’) 0 10 format(*args,**kwargs) 字符串格式化，使用时字符串中需要包含{} ‘帅帅 {}’.format(‘Python’) ‘帅帅 Python’ 11 format_map(mapping) 类似 str.format(*args, **kwargs) ，不同的是 mapping 是一个字典对象 ‘My name is {name},i am {age} old’.format_map({‘name’:’付帅帅’, ‘age’:18}) ‘My name is 付帅帅,i am 18 old’ 12 index(sub[, start[, end]]) 跟find()方法一样，只不过如果str不在字符串中会报一个异常 ‘hello word!’.index(‘word’) 6 13 isalnum() 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False ‘123a12’.isalnum() True 14 isalpha() 如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False ‘abcd’.isalpha() True 15 isdecimal() 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false ‘12312’.isdecimal() True 16 isdigit() 如果字符串只包含数字则返回 True 否则返回 False.. ‘123’.isdigit() True 17 isidentifier() 判断字符串是否可为合法的标识符 ‘dobi 123’.isidentifier() False 18 islower() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False ‘Ab’.islower() False 19 isnumeric() 如果字符串中只包含数字字符，则返回 True，否则返回 False ‘Sjd2’.isnumeric() False 20 isprintable() 判断字符串的所有字符都是可打印字符或字符串为空 ‘handsomeFu 123’.isprintable() True 21 isspace() 如果字符串中只包含空格，则返回 True，否则返回 False. ‘ ‘.isspace() True 22 istitle() 如果字符串是标题化的(见 title())则返回 True，否则返回 False ‘handsomeFu Blog’.istitle() False 23 isupper() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False ‘handsomeFu’.isupper() False 24 join(iterable) 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 ‘-‘.join([‘2012’, ‘3’, ‘12’]) ‘2012-3-12’ 25 ljust(width[, fillchar]) 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格 ‘handsomeFu’.ljust(9, ‘^’) ‘handsomeFu^^’ 26 lower() 转换字符串中所有大写字符为小写. ‘ABcdEf’.lower() ‘abcdef’ 27 lstrip([chars]) 截掉字符串左边的空格 ‘ handsomeFu’.lstrip() ‘handsomeFu’ 28 maketrans(x[, y[, z]]) 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标 str.maketrans(‘abce’, ‘1234’) {97: 49, 98: 50, 99: 51, 101: 52} 29 partition(sep) 用指定的分隔字符串(参数sep)来分隔原字符串，返回一个包含三个元素的元组。 如是指定的分隔字符串(参数sep)在原字符串中存在，则返中的元组中前后两个元素分别为被分隔开的原字符串（不包括分隔字符串），中间元素为分隔字符中。 ‘handsome0219’.partition(‘h’) (‘’, ‘h’, ‘andsome0219’) 30 replace(old, new[, max]) 把将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次 ‘dog wow wow jiao’.replace(‘wow’, ‘wang’, 2) ‘dog wang wang jiao’ 31 rfind(sub[, start[, end]]) 类似于 find()函数，不过是从右边开始查找 ‘outer protective covering’.rfind(‘er’, 20, 21) -1 32 rindex(sub[, start[, end]]) 方法返回子字符串最后一次出现在字符串中的索引位置，该方法与[ rfind()] 方法一样，只不过如果子字符串不在字符串中会报一个异常。 ‘love python love python!’.rindex(‘python’) 17 33 rjust(width[, fillchar]) 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串 “this is string example….wow!!!”.rjust(50, ‘*’) ‘**this is string example….wow!!!’ 34 rpartition(sep) 从后往前查找，返回包含字符串中分隔符之前、分隔符、分隔符之后的子字符串的tuple；如果没找到分隔符，返回字符串和两个空字符串 “handsomeFu is very handsome”.rpartition(‘o’) (‘handsomeFu is very hands’, ‘o’, ‘me’) 35 rsplit(sep=None, maxsplit=-1) 通过指定分隔符对字符串进行分割并返回一个列表，默认分隔符为所有空字符，包括空格、换行(\n)、制表符(\t)等。类似于 [split()] 方法，只不过是从字符串最后面开始分割。 “this is a ipython3”.rsplit(‘i’,1) [‘this is a ‘, ‘python3’] 36 rstrip([chars]) 删除字符串字符串末尾的空格 “this is handsomeFu “ .rstrip() “this is handsomeFu111”.rstrip(“1”) “this is handsomeFu” “this is handsomeFu” 37 split(sep=None, maxsplit=-1) num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num 个子字符串 ‘123423664234’ .split(‘2’) [ ‘1’, ‘34’ , ‘3664’, ‘34’] splitlines([keepends]) 按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 ‘ab c\n\nde fg\rkl\r\n’.splitlines(); [‘ab c’, ‘’, ‘de fg’, ‘kl’] 39 startswith(prefix[, start[, end]]) 检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查 ‘mynameis’.startswith(‘na’,2,7) True strip([chars]) 在字符串上执行 lstrip()和 rstrip() ‘ abc ‘.strip() ‘abc’ 41 swapcase() 将字符串中大写转换为小写，小写转换为大写 “this is handsomeFu”.swapcase() THIS IS handsomeFu 42 title() 返回”标题化”的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) ‘this is handsomeFu’.title() ‘This Is handsomeFu’ 43 translate(table) 根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中 ma = str.maketrans(‘abce’, ‘1234’) st = ‘abcdefgabcd’ st.translate(ma) ‘123d4fg123d’ 44 upper() 转换字符串中的小写字母为大写 “python”.upper() PYTHON 45 zfill(width) 返回长度为 width 的字符串，原字符串右对齐，前面填充0 ‘handsomeFu’.zfill(12) ‘00handsomeFu’]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型]]></title>
    <url>%2F2017%2F12%2F28%2FJavascript%2FdataType%2F</url>
    <content type="text"><![CDATA[数据类型 javascript中有6中数据类型String Number Boolean Object undefined function ES6新添加了一种原始数据类型Symbol typeofjavascript中通过 typeof 检测一个数据类型，返回一个字符串 1234567891011121314151617181920var str = "javascript";var num = 10;var nu = null;console.log(typeof str); // stringconsole.log(typeof num); // numberconsole.log(typeof null); // objectconsole.log(typeof typeof str); // string （返回的是一个字符串）// undefined 未定义数据类型var foo;console.log(foo); // undefinedvar undefined = 66;console.log(undefined); // 66 undefined可以被定义成变量名 通常不会这么做容易产生歧义// nullvar bar = null;console.log(typeof bar); // object 返回object // undefined是变量未初始化 null是一个空对象 但是undefined == null js在判断 "等值" 操作的时候会返回true 尽管有这样子的关系 但是它们两的使用差别很大 ps : typeof 并不是一个绝对安全的判断数据类型的方式 后边学习其它数据类型的准确方式。例如精确的判断数组、日期等等。 var 与 let constjs中声明变量使用 var 关键字,同样 let const 也可以用来声明变量 做一个简单的比较说明一下 123456var a = 10;b = 20;delete a;delete b;console.log(a); // 10console.log(b); // 报错 not defined 声明变量如果不加 var 那么这个变量可以被delete删除 var相当于一个标记 毕竟声明在全局的变量相当于window.b = 20 可以通过delete删除对象属性 123456789101112&#123; var a = 10; let b = 10;&#125;console.log(a); // 10console.log(b); // 报错 not definedfor(var i=0;i&lt;3;i++)&#123; //... &#125;console.log(i); // 3 for(let j=0;j&lt;3;j++)&#123; // ... &#125;console.log(j); // 报错 let 关键字声明的变量只在所在的代码块生效 看大括号的范围 所以let很适合用在for循环, 在循环体外引用就会报错 最常见的遍历节点获取索引的操作 使用 let 的循环可以很轻松的获取到对应的索引 变量提升 123456console.log(a); // undefinedvar a = 10;// console.log(b); // 报错let b = 10;console.log(b); // 10 var 声明的变量会发生变量提升 js在编译阶段会把变量进行提升 let 声明的变量不会出现 变量一定 “要被声明之后” 才可以被使用也很符合正常的使用 毕竟要先有女朋友才可以一起做羞羞的事情 1const PI = 3.1415926; const 声明一个只读的常量, 声明之后必须立即赋值, 区别与 var let 可以声明之后在赋值 const会报错, 同样const不会产生变量提升, 只在所在代码块生效 简单的介绍了一下js中数据类型其中很多地方例如 ( 在后边在补充 ) 为什么 typeof 不能准确的判断数据类型 变量提升 块级作用域]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[规范说明]]></title>
    <url>%2F2017%2F12%2F05%2Fhtml%26css%2F14%20standard%2F</url>
    <content type="text"><![CDATA[layout 上一篇内容相信大家应该掌握了，了解css中的属性值及其特性，分析问题与需求选择合适的解决方案。这一节讨论一下规范。 HTML规范html的书写相对来说想写错真的太难了但是同样我们需要一个规范。无论从团队配合还是约定内容都是必须要遵守的。 代码规范 声明html5的doctype 所有的html代码都使用小写 页面编码采用gbk，在系统允许的前提下可以使用utf-8 页面内容lang=zh-Hans-CN 以前的zh-CN已经被废除，当然废除不代表不生效了。 在head中添加对页面相关人员团队的注释 1&lt;!-- 页面设计：xxx | 页面制作：xxx | 团队博客：http://tgideas.qq.com/ --&gt; 内容性质的图片必须加上alt属性，修饰性的图片可以不加，width与height值为原始大小 注释的写法 IE条件注释 12345678910111213141516171819&lt;!-- [if IE]&gt;这里只有ie浏览器才可以显示&lt;![endif]--&gt; &lt;!-- [if !IE]&gt;这里只有非ie浏览器才可以显示&lt;! &lt;![endif]--&gt; &lt;!--[if IE 6]&gt;这里只有ie6浏览器才可以显示&lt;![endif]--&gt; &lt;!--[if lt IE 9]&gt;这里只有ie9以下浏览器才可以显示&lt;![endif]--&gt; &lt;!--[if lte IE 8]&gt;这里只有ie8以及ie8以下浏览器才可以显示&lt;![endif]--&gt; 对注释中的空白区域用等号替换 1&lt;!-- header======header --&gt; 对于需要转义的字符使用转义字符 &amp;lt; &amp;gt; 等等 单标签不要写 / 闭合，声明为html5页面会自动处理 img、br、hr、input 元素嵌套段落标签嵌套内联标签，块级标签嵌套内联标签 对标签的特性熟悉对应的内容使用怎样的标签，及对网页标签的合理应用 CSS规范命名规范 ID 在页面中具有唯一性，也就是说以ID做为选择器来写css就无法重用，使用类名选择器定义样式，避免使用ID定义。 以字母开头 不允许单个字母的类选择器出现，单词名字使用有意义的名字，结构化的名字与作用相关的名字 不允许命名带有广告等英文的单词，例如ad,adv,adver,advertising，已防止该模块被浏览器当成垃圾广告过滤掉。 全部小写，使用 - 连接多个单词的class，不要使用下划线，禁止使用驼峰 文件名 基本样式 base.css 全局样式 global.css 布局样式 layout.css 字体样式 font.css ​ 常用名整页.wrap 页眉.header 页脚 .footer 导航 .nav 主体内容 .main 侧边栏.side 标志 .logo 搜索 .search 登录 .login 注册 .reg 标题 .tit 按钮.btn- 背景图片 .bg- 列表 .list- 表格 .tb- 标签 .tag- 视频 .video- 联系 .contact 书写风格 单个css选择器或新申明开启新行 1234.container,.header,.home,.nav&#123; font-size: 12px&#125; ​ 内容属性顺序 12345678910111213/* 这些属性只是最常用到的, 并不代表全部 *//* 布局定位属性 */display / list-style / position / float / clear / visibility / overflow/* 自身属性 */width / height / margin / padding / border / background/* 文本属性 */color / font / text-decoration / text-align / vertical-align / white- space / break-word/* 其他（CSS3） */content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient ​ 属性时候换行随意个人习惯，最后都要被压缩，写一个属性后边冒号空一格 width: 100px 尽可能利用css控制交互视觉变换JS操作的只需要添加删除类名 注释 123/*=====头部=====*/.header &#123;background-color: #333;height: 100px;&#125;/*=====头部结束=====*/ ​ last这几天的练习抓住几个点 布局看高度颜色，间距看文字距离。 类名组合写法 一个页面不要很多的父级元素 虽然说会产生一些代码嵌套 但是总的来说结构会比较清晰 类名组合使用 结构是结构 样式是样式 有时候可能会改变标签书写顺序，导致增加一些标签。考虑到以后可能的改变利大于弊 最后一定要细心 出了问题 别着急了 重新打开一个备份 标签是否闭合 可能会导致浏览器解析的时候出错 掌握每个css属性的特性，特性使然 讲道理其实就是一个慢工出细活，如果这点耐心都没有是不行的哦。么么哒~]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>HTML+CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[layout布局]]></title>
    <url>%2F2017%2F12%2F02%2Fhtml%26css%2F13%20layout%2F</url>
    <content type="text"><![CDATA[layout 布局是UI设计师将有限的视觉元素进行有机的排列组合。将理性的思维个性化的表现出来是一种具有个人风格和艺术特色的视觉传达方式。 分栏又称为分列，常见的布局有一列、两列、三列、混合布局。我们需要通过css中的浮动定位完成UI设计中的布局要求，所以前端工程师就是将艺术与技术完美融合的岗位。 多列布局一列布局单页的应用没有太多的内容，文字内容较少。 1234567891011&lt;style&gt; .header&#123;height: 80px;background: #ddd;&#125; /* 主体main高度肯定是要靠内容去撑起来的实际中不用给 */ .main&#123;width: 800px;height: 800px;background: #111;&#125; .footer&#123;height: 80px;background: #333;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="header"&gt;&lt;/div&gt; &lt;div class="main"&gt;&lt;/div&gt; &lt;div class="footer"&gt;&lt;/div&gt;&lt;/body&gt; 两列布局两列布局很常见，具体的可以通过浮动或flex example 1 12345678910111213&lt;style&gt; /* 两列固定宽度 float */ .clearfix::after&#123;content: '';display: table;clear: both;&#125; .wrap&#123;width: 1000px;margin-left: auto;margin-right: auto;&#125; .left&#123;float: left;width: 300px;background: red;&#125; .right&#123;float: right;width: 700px;background: blue;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="wrap clearfix"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; example 2 1234567891011121314151617181920&lt;style&gt; /* 一列定 一列自适应 table */ /* 简单解释一下这个原理 table设定的容器内部的元素按照表格排列，并且每列单元格的宽度和一定等于总的宽度 table-cell设定的元素不会超出父元素的宽度 一般给2000 当然如果你是4k屏幕分辨率高的惊人可以设置成9999 另外table-cell设定后margin失效 需要间距设定padding 这里也可以不用外层的 如果需要居中则嵌套一层 table-layout: fixed 这个属性用来加速浏览器的渲染 */ .parent&#123;display: table;table-layout: fixed;width: 100%;&#125; .left&#123;float: left;width: 400px;height: 400px;background: red;&#125; .right&#123;display: table-cell;width: 2000px;height: 400px;background: blue;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="parent"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; example 3 123456789101112131415&lt;style&gt; /* float + overflow 缺点溢出不可见 需要居中加一层 */ .left&#123;float: left;width: 300px;height: 400px;background-color: red;&#125; .right&#123;overflow: hidden;background-color: blue;&#125; .right div&#123;width: 100px;height: 90px;background-color: yellow;margin:10px 0 0 -10px;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; example 4 123456789101112&lt;style&gt; /* flex 除了兼容问题没毛病 */ .parent&#123;display: flex;&#125; .left&#123;width: 400px;height: 400px;background-color: blue;flex:0 0 400px;&#125; .right&#123;width: 2000px;height: 400px;background-color: red;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="parent"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 三列布局三列布局的一般为左右两边定宽 中间自适应 方法手段很多只是每一种html结构差异 example 1 1234567891011121314&lt;style&gt; /* 两边定位 中间用margin定位 缺点：当父元素有margin的时候 中间的会被挤下去 */ .left&#123;width: 300px;height: 400px;background-color: red;position: absolute;top: 0;left: 0;&#125; .middle&#123;height: 400px;background-color: blue;margin: 0 210px 0 310px;&#125; .right&#123;width: 200px;height: 400px;background-color: black;position: absolute;top: 0;right: 0;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/body&gt; example 2 1234567891011121314&lt;style&gt; /* 两边浮动 中间margin定位 html结构产生了变化 缺点：两列和小于width之和右边会掉下去 */ .left&#123;float: left;width: 300px;height: 400px;background-color: red;&#125; .right&#123;float: right;width: 200px;height: 400px;background-color: black;&#125; .middle&#123;height: 400px;background-color: blue;margin: 0 210px 0 310px;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt;&lt;/body&gt; example 3 12345678910111213141516&lt;style&gt; /* flex 布局 除了兼容问题 */ .wrap&#123;display: flex;width: 1200px;margin: 0 auto;&#125; .left&#123;width: 200px;height: 300px;background: green;flex: 0 0 200px;&#125; .middle&#123;width: 100%;background: red;margin:0 10px;&#125; .right&#123;width: 200px;height: 300px;background: yellow;flex: 0 0 200px;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="middle"&gt;&lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; example 4 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;style&gt; /* 圣杯布局 一个流传很久的布局 有兴趣自行查看 */ #container &#123; padding-left: 200px; /* LC width */ padding-right: 150px; /* RC width */ &#125; #container .column &#123; position: relative; float: left; padding-top: 1em; text-align: justify; &#125; #center &#123; width: 100%; background: #DDD; &#125; #left &#123; width: 200px; /* LC width */ height: 400px; right: 200px; /* LC width */ margin-left: -100%; background: #66F; &#125; #right &#123; width: 150px; /* RC width */ height: 400px; margin-right: -100%; background: #F66; &#125; #footer &#123; clear: both; &#125;&lt;/style&gt;&lt;body&gt; &lt;div id="header"&gt;This is the header.&lt;/div&gt; &lt;div id="container"&gt; &lt;div id="center" class="column"&gt; &lt;h1&gt;This is the main content.&lt;/h1&gt; &lt;p&gt;center&lt;/p&gt; &lt;/div&gt; &lt;div id="left" class="column"&gt; &lt;h2&gt;This is the left sidebar.&lt;/h2&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div id="right" class="column"&gt; &lt;h2&gt;This is the right sidebar.&lt;/h2&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id="footer"&gt;footer.&lt;/div&gt;&lt;/body&gt; 居中水平居中子元素在父元素中居中且宽度均可变 123456789101112131415161718192021222324/* inline-block + text-align */.outer&#123;text-align: center;&#125;.inner&#123;display: inline-block;&#125;/* margin .inner&#123;margin-left: auto;margin-right: auto;&#125;*//* flex .outer&#123;display: flex;justify-content: center;&#125;*//* table + margin 兼容性最好 .inner&#123;display: table;margin-left: auto;margin-right: auto;&#125;*//* absolute + transform .outer&#123;position: relative;&#125; .inner&#123;position: absolute;left: 50%;transform: translateX(-50%);&#125;*/ 垂直居中1234567891011.outer &#123;display: table-cell;vertical-align: middle;&#125;/* absolute + transform .outer&#123;position: relative;&#125; .inner&#123;position: absolute;top: 50%;transform: translateY(-50%);&#125;*//* .outer&#123;display: flex;align-item: center;&#125;*/ 水平垂直居中123456789101112131415161718.outer &#123;text-align: center;display: table-cell;vertical-align: middle;&#125;.inner &#123;display: inline-block;&#125;/* absolute + transform .outer&#123;position: relative;&#125; .inner&#123;position: absolute;top: 50%;left: 50%;transform: translate(-50%, -50%);&#125;*//* .outer&#123;position: relative&#125; .inner&#123;width: 100px;height: 100px;position: absolute;top: calc(50% - 50px);left: calc(50% - 50px);&#125;*//* flex .outer&#123;display: flex;justify-content: center;align-items: center;&#125;*/ last基础真的很重要，不能只关注深层的东西而忽略了它，很多时候我们都只关注这个新的技术，各种各样的框架组件。感叹的同时却还在原地踏步！挖掘简单事物背后的不简单，想信我们就真的进步了！ 风起于青萍之末，浪成于微澜之间。生活多姿多彩等待你我去发现！么么哒~]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[animation动画]]></title>
    <url>%2F2017%2F12%2F01%2Fhtml%26css%2F12%20animation%2F</url>
    <content type="text"><![CDATA[CSS3的animation动画，结合transform元素可以被转换（translate）、旋转（rotate）、缩放（scale）、倾斜（skew），可以做出很多有趣的效果。 transform、transition首先CSS3的 transform 属性 , 只对 block 级元素生效！transform 是 CSS3 中一个可以针对2D或3D的变化属性 。transform只能定义几何变化，不能改变颜色，背景，透明度等非几何变化。列举一些常用的变化属性。 translate，translateX, translateY, translateZ rotate, rotateX, rotateY, rotateZ scale, scaleX, scaleY skew, skewX, skewY 指定了 transform 的元素会立即发生改变，需要配合 transition 一起来使用，用transition属性为transform变化指定属性、持续时间、运动曲线、 延迟时间。添加了必要的动画参数才是一个完整的动画，否则单独的transform不会有动画效果。 transition: &lt; property &gt; &lt; duration &gt; &lt; timing-function &gt; &lt; delay &gt;; tip：transition与transform不同的地方在于前者可以改变非几何属性，即transform无法变化的属性。 example1 12.box&#123;width: 100px;height: 100px;background-color: red;margin: 100px auto;transition: width 2s;&#125;.box:hover&#123;width: 200px;&#125; 并且可以变化多个属性通过逗号分隔。 example2 12.box&#123;width: 100px;height: 100px;background-color: red;margin: 100px auto;transition: width 2s, height 2s, background 2s, opacity 2s, transform 2s;&#125;.box:hover&#123;width: 200px;height: 200px;background: blue;opacity: .3;transform: rotate(180deg) translateX(100px);&#125; 提醒一下transform如果在别的浏览器不兼容记得加浏览器兼容的前缀！ -webkit-transform: rotate(); -moz-transform: rotate(); -ms-transform: rotate(); -o-transform: rotate(); example3 1234567891011121314151617181920212223242526&lt;style&gt;.box&#123; /*transition-property: background-color, color; transition-duration: 1s; transition-timing-function: ease-out;*/ /* 可以一句话写完 */ transition: background-color, color, 1s ease-out; /* transition: all 1s ease-out; */ background-color: grey; width: 60px; height: 26px; color: white; font-size: 20px; text-align: center; box-shadow: 2px 2px 1px black; padding: 2px 4px;&#125;.box:hover&#123; background-color:#AA7EF6; color:black; box-shadow: 2px 2px 1px black;&#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt;Css3&lt;/div&gt;&lt;/body&gt; example4 1234567891011121314151617181920#heart &#123; position: relative; width: 100px; height: 90px; transition: all 1s ease-out;&#125;#heart::before, #heart::after &#123; position: absolute; content: ""; left: 50px; top: 0; width: 50px; height: 80px; background: red; border-radius: 50px 50px 0 0; transform: rotate(-45deg); transform-origin: 0 100%;&#125;#heart:after &#123;left: 0;transform: rotate(45deg);transform-origin :100% 100%;&#125;#heart:hover&#123;transform: scale(1.2);&#125; 这个例子看到了一个新的属性 transform-origin 可以用来控制元素的旋转基点。x轴、y轴两个方向，可以使用top、left、right、bottom、%来设定基点位置。除了百分数其它的四个都是位置。设定一个就是对应的边的中点 animation @keyframes关键祯 是专门用来做动画的，它可以指定具体到某一帧的状态是什么样子的，以整数百分比来指定帧数，再给定CSS属性，就组成了一组状态的变化。 12345678910@keyframes move&#123; from&#123;width: 100px;&#125; to&#123;width: 200px;&#125;&#125;@keyframes move&#123; 0%&#123;width: 100px;&#125; 50%&#123;width: 150px;&#125; 100%&#123;width: 200px;&#125;&#125; 同样在不同的浏览器如果没有效果的记得加前缀 @-webkit-keyframes @-moz-keyframes @-ms-keyframes @-o-keyframes @keyframes 是制作动画的过程，animation 就是一台放映机，规定动画的播放时间、速率、延迟、次数、反向轮播。 example1 12345678910111213141516171819202122232425262728&lt;style&gt;.view &#123; background-color:black; width:500px; height:20px; margin: 100px auto; overflow: hidden;&#125;.eye &#123; color:white; height: 100%; width: 25%; background-color: red; background-image: -webkit-linear-gradient(left, rgba( 0,0,0,0.9 ) 25%, rgba( 0,0,0,0.1 ) 50%, rgba( 0,0,0,0.9 ) 75%); animation: move 4s linear 0s infinite alternate;&#125; @keyframes move &#123; from &#123;margin-left:-20%;&#125; to &#123;margin-left:100%;&#125;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="view"&gt; &lt;div class="eye"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 3D两个属性 perspective: 800 transform-style: preserve-3d; 景深的大小决定的是元素距离你的视距的长短 example 翻书demo 12345678910111213141516171819202122&lt;style&gt; .list&#123;width: 400px;height: 200px;background-color: white;margin: 100px auto;position: relative;-webkit-perspective: 800;transform-style: preserve-3d;transform: rotateX(30deg);&#125; .list li&#123;position: absolute;width: 200px;height: 195px;top: 2px;background: white;left: 200px; transform-origin: left;text-align: center;line-height: 195px;&#125; .list li:nth-child(1)&#123; animation: move 3s linear infinite; &#125; .list li:nth-child(2)&#123; animation: move 3s linear 1.5s infinite; &#125; @keyframes move&#123; from&#123; transform: rotateY(0deg);&#125; to&#123; transform: rotateY(-180deg);&#125; &#125;&lt;/style&gt;&lt;body&gt; &lt;ul class="list"&gt; &lt;li&gt;我爱你&lt;/li&gt; &lt;li&gt;么么哒&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>html5&amp;css3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex 弹性盒模型]]></title>
    <url>%2F2017%2F11%2F30%2Fhtml%26css%2F11%20flex%2F</url>
    <content type="text"><![CDATA[flex讲解 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size 容器的属性 flex-direction 排列方向 row | row-reverse | column | column-reverse flex-wrap nowrap | wrap | wrap-reverse justify-content 主轴对齐方式 flex-start | flex-end | center | space-between | space-around align-items 交叉轴对齐方式 flex-start | flex-end | center | baseline | stretch 子元素的flex属性：flex 属性是 flex-grow， flex-shrink 和 flex-basis 的简写，默认值为0 1 auto。后两个属性可选。 flex-grow 定义项目的放大比例 flex-shrink定义项目的缩小比例 flex-basis 定义了在分配多余空间之前，浏览器根据这个属性，计算主轴是否有多余空间 默认auto tip： 在基准值之内grow分配之外之外多余的部分按照grow的比例分配，超出的量按照shrink比例收缩并且basis失效。]]></content>
      <categories>
        <category>html5&amp;css3</category>
      </categories>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里图标]]></title>
    <url>%2F2017%2F11%2F30%2Fhtml%26css%2F10%20iconfont%2F</url>
    <content type="text"><![CDATA[阿里图标 阿里矢量图标不是图片，是一种字体。 优点 可以通过font的css样式美化修改图标，不需要考虑背景位置（图片、雪碧图需要）。 放大缩小屏幕的时候不会失真。因为只需要修改字体大小就可以，如果使用图片的时候我们就可能需要一大一小两张图片了。 加载字体文件和图片文件相比较，字体的体积更加的小，而且图片自身也需要加载时间。 相比较于图片，图片不能很好地进行缩放，当图片进行放大时会失真（即变模糊），当图片进行缩小时就会浪费掉像素。而且加载张图片都需要发起请求，因此也拖慢了整个加载页面的时间。如果需要对图片进行编辑、处理等操作，没有专门的图片工具也很不好去修改。 使用阿里图标的使用有三种形式unicode、font-class、symbol。首推Unicode毕竟官网也是这么推荐的。三种的兼容性略有不同分别支持的范围IE6+、IE8+、IE9+。 在使用前请务必把所需要的图标添加到自己的项目文件夹。 一般来不推荐下载使用，推荐在线使用切换，修改相比较都容易。 unicode引用 使用font-face引入在线的阿里图片链接，并且设定iconfont样式，最后挑选对应图片的unicode代码（类似&#xe666;）。 12345678910111213141516171819202122&lt;style&gt; /* 这里的地址需要在项目文件夹中生成！ */ @font-face &#123;font-family: 'iconfont'; src: url('iconfont.eot'); src: url('iconfont.eot?#iefix') format('embedded-opentype'), url('iconfont.woff') format('woff'), url('iconfont.ttf') format('truetype'), url('iconfont.svg#iconfont') format('svg'); &#125; .iconfont&#123; font-family:"iconfont" !important; font-size:16px;font-style:normal; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale; &#125;&lt;/style&gt;&lt;body&gt; &lt;!-- 推荐使用i标签，做为图标标签 切记加上iconfont类名 --&gt; &lt;i class="iconfont"&gt;&amp;#xe605;&lt;/i&gt;&lt;/body&gt; font-class 与unicode的区别就是在于语义明确的程度，使用同样在我的项目文件中生成css链接 12345678&lt;head&gt; &lt;!-- 这里的地址需要在项目文件夹中生成！--&gt; &lt;link rel="stylesheet" href="http://at.alicdn.com/t/font_8d5l8fzk5b87iudi.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 推荐使用i标签，做为图标标签 切记加上iconfont类名 --&gt; &lt;i class="iconfont icon-xxx"&gt;&lt;/i&gt;&lt;/body&gt; symbol symbol的引用和前两者最大的区别其实在于颜色，但是只支持高级浏览器以及IE9+。当我们需要使用多色图片的时候可能需要使用多个图片互相组合。上面的两种也只能使用一些css颜色样式不能做到多色的图片，那么这个时候就需要使用到symbol（svg） 同样在我的项目中生成对应的 js 链接。看清楚了哦js文件，在style中添加样式，固定格式添加。如果觉得小可以在项目中修改图标的大小。 1234567891011121314&lt;style type="text/css"&gt; .icon &#123; width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; &#125;&lt;/style&gt;&lt;script src="http://at.alicdn.com/t/font_8d5l8fzk5b87iudi.js"&gt;&lt;/script&gt;&lt;body&gt; &lt;svg class="icon" aria-hidden="true"&gt; &lt;use xlink:href="#icon-xxx"&gt;&lt;/use&gt; &lt;/svg&gt;&lt;/body&gt; tip：三种方式各有优缺点。但是需要注意的是每次往项目中添加了新的图标，无论上述哪一种都需要重新生成一次链接，否则新添加的图片是不会有效果的。 下载当我们的项目的结束的时候所有的图标都确定了之后我们可以选择下载，在过程中或许会去调整图片每次都下载是一件很麻烦的事情，所以在没有结束，没有确定所需要的图标的时候，推荐使用在线的图标。方便修改替换。]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>HTML+CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[position定位]]></title>
    <url>%2F2017%2F11%2F28%2Fhtml%26css%2F09%20position%2F</url>
    <content type="text"><![CDATA[ps：图片和内容无关只是觉得好看，找不到图了。。。 定位 CSS中定位是布局中经常会用到的。需要大家对文档流有一定的了解。 position属性 static，默认值。位置设置为static的元素，它始终会处于文档流给予的位置。 absolute，生成绝对定位的元素，相对于距该元素最近的已定位的祖先元素进行定位。此元素的位置可通过 “left”、”top”、”right” 以及 “bottom” 属性来规定。 relative，生成相对定位的元素，相对于该元素在文档中的初始位置进行定位。通过 “left”、”top”、”right” 以及 “bottom” 属性来设置此元素相对于自身位置的偏移。 fixed，生成绝对定位的元素。默认情况下，可定位于相对于浏览器窗口的指定坐标。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。不论窗口滚动与否，元素都会留在那个位置。 sticky, 粘性定位(relative+fixed)。在一定阈值下是 relative 超过了变成 fixed 。 不管是哪种定位，都必须有一个参照物。找对了参照物，就成功了一半。 相对定位relative 给定的元素，会相对与原来的正常位置进行定位。使用top、left、right、bottom来偏移。 tip：相对定位的元素会保留原来的位置，并且relative的元素没有脱离文档流，毕竟还占据原来的位置。 绝对定位absolute 给定的元素，与相对定位的元素最大的区别就是，这个元素将脱离文档流的束缚，其它的元素会认为这个元素不存在而去填充它原来的位置，绝对定位的元素会参照定位上下文（定位父级） 来移动自己的位置。如果没有设定定位父级默认就是body。 设定了定位父级按照最近的父级做为参照。 1234567&lt;div class="box1" style="position: relative"&gt; &lt;div class="box2" style="position: absolute"&gt; &lt;div class="box3" style="position: absolute"&gt; box3的定位父级是最近的box2 不是box1 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; over 遮罩层 注意点：这里设定的宽度高度是根据window的窗口大小来的，并不是body和html的大小，因为body和html的默认的大小是根据内容来撑开的。通过iframe设定高度可以得到验证。设置z-index遮罩层的层级一定是最高的所以一般可能会看到一些网站的遮罩层会设定99或者999当然这要能让它显示在最上边就好了。 123456&lt;style&gt; .over&#123;position: absolute;top: 0;left: 0;z-index: 99;width: 100%;height: 100%;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="over"&gt;&lt;/div&gt;&lt;/body&gt; 多个元素设定absolute时候会发生重叠，与单个元素设定定位不一样（与relative一样，暂时保持当前位置，只是脱离了文档流的束缚）。一些特定的场景需要设定absolute，比如二级菜单，banner等等。 固定定位fixed 给定的元素，定位上下文始终是浏览器窗口，不会随着body的移动而改变位置（这里讲错了，上课的时候说的是body，但是仔细想一下如果是相对与body的话，那么body在滚动的时候肯定也会发生位置的改变，注意一下）。 一般需要固定在页面上的元素，不会随着页面的滚动而发生偏移的元素，请使用 fixed 定位。 粘性定位example 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;style&gt; .wrap&#123;width: 400px;height: 300px;margin: 30px auto;overflow: auto&#125; dl &#123; margin: 0; padding: 10px 0 0 0; &#125; dt &#123; background: #B8C1C8; border-bottom: 1px solid #989EA4; border-top: 1px solid #717D85; color: #FFF; font: bold 18px/21px sans-serif; margin: 0; padding: 2px 0 0 12px; position: -webkit-sticky; position: sticky; top: -1px; &#125; dd &#123; font: bold 20px/45px sans-serif; margin: 0; padding: 0 0 0 12px; white-space: nowrap; border-top: 1px solid #CCC &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="wrap"&gt; &lt;dl&gt; &lt;dt&gt;A&lt;/dt&gt; &lt;dd&gt;Andrew W.K.&lt;/dd&gt; &lt;dd&gt;Apparat&lt;/dd&gt; &lt;dd&gt;Arcade Fire&lt;/dd&gt; &lt;dd&gt;At The Drive-In&lt;/dd&gt; &lt;dd&gt;Aziz Ansari&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;C&lt;/dt&gt; &lt;dd&gt;Chromeo&lt;/dd&gt; &lt;dd&gt;Common&lt;/dd&gt; &lt;dd&gt;Converge&lt;/dd&gt; &lt;dd&gt;Crystal Castles&lt;/dd&gt; &lt;dd&gt;Cursive&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;E&lt;/dt&gt; &lt;dd&gt;Explosions In The Sky&lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt;&lt;/body&gt; 测试下就明白了 层级顺序 页面文档中的元素会按照一定的规则去显示。 内容是页面的很重要的实体，因此层叠水平较高。 example 123456789&lt;style&gt; div&#123;width: 200px;height: 100px;font-size: 20px;&#125; .a&#123;background: red;&#125; .b&#123;background: blue;margin: -35px 0 0 10px;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="a"&gt;box1&lt;/div&gt; &lt;div class="b"&gt;box2&lt;/div&gt; &lt;/body&gt; 上边的例子可以看到一些现象 盒子 box2 会挡住盒子 box1 ，元素产生了覆盖，颜色的覆盖。页面中的排布遵循元素排布规则。相同的元素后来居上。 文字覆盖也是后来居上的。 example 12345678910111213&lt;style&gt; div&#123;width: 200px;height: 100px;font-size: 20px;&#125; .a&#123;display: inline-block;background: red;&#125; .b&#123;background: blue;margin: -35px 0 0 10px;&#125; .c&#123;background: black;&#125; .d&#123;display: inline-block;background: green;margin: -35px 0 0 10px;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="a"&gt;box1&lt;/div&gt; &lt;div class="b"&gt;box2&lt;/div&gt; &lt;div class="c"&gt;box3&lt;/div&gt; &lt;div class="d"&gt;box4&lt;/div&gt;&lt;/body&gt; 当设定了元素的显示属性的时候按照上边的层叠规则可发现，此时元素没有按照后来居上的原则来了。这里还可以加一个浮动元素去验证。 此时盒子之间的覆盖，背景颜色的覆盖始终都是遵循层叠顺序。 文字还是后来居上。再次强调一下文字是内容实体很重要。 关于定位元素的层叠顺序 首先要了解两个东西 层叠上下文：页面根节点（body），是根层叠上下文（参考对象），请把它理解成容器，容器就是盛放物品的，物品在其中是有层叠顺序的。 层叠水平：层叠上下文的元素，以及普通的元素都具有层叠水平。层叠水平决定了元素在同一个层叠上下中显示的顺序（学生和老师之间的距离）。 example1 12345678910&lt;style&gt; .outer&#123;width: 300px;height: 300px;border: 1px solid red;&#125; .inner&#123;width: 200px;height: 100px;position: absolute;/* float: left */&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="outer"&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;!-- 很多的文字 --&gt; &lt;/div&gt;&lt;/body&gt; 文字被inner元素所覆盖，因为设定了定位的元素具有默认的z-index： auto。和浮动比较，两者遵循层叠顺序 z-index： auto 的元素会排列在float元素之上。 example2 123456789&lt;style&gt; .outer&#123;width: 100px;height: 150px;position: relative;background: red;/* z-index: 1; */&#125; .inner&#123;width: 200px;height: 100px;position: absolute;z-index: -1;background: black;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="outer"&gt; &lt;div class="inner"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 给inner设定了z-index：-1时inner元素跑到了outer元素的后边。遵循负值z-index排列在block元素之后。 如果此时给父级元素设定z-index: 1;这里任意数值，会发现outer显示到了后边，这个时候再去调整inner的z-index值就算再大也不会超越outer的显示层级。什么原因呢？ tip：定位元素具有z-index默认值auto，但是auto不会是元素成为层叠上下文。设定数值之后定位元素就会成为层叠上下文，inner此时在outer中就是遵循层叠顺序来排列，outer即变成了盛放内容的容器了。inner设定的z-index只是会影响outer内部的层叠水平。不会影响影响与outer之间的层叠顺序。 example3 ：最后一点就不举例子了。当有互相嵌套的时候并且父级也有z-index值的时候，层叠顺序的比较止步于父级的层叠上下文（父级在其层叠上下中的排列顺序）。 总结： 定位元素默认具有z-index：auto（可以看成0）。 z-index：auto不会创建定位上下文。 z-index层叠顺序的比较止步与父级层叠上下文。 last打完收工！有问题留言补充，再修改。晚安，么么哒~]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[float浮动]]></title>
    <url>%2F2017%2F11%2F22%2Fhtml%26css%2F08%20float%2F</url>
    <content type="text"><![CDATA[float 让人又爱又恨的~浮动 float history在很久很久很久以前（多么熟悉的旋律），浮动就已经出现了。拿来干嘛的呢？ one： 最初仅仅为了实现传统报刊出版物上边的 文字环绕 效果。 two： 让上下排列的元素不在堆叠，变成左右的排列，从而实现布局的很多的效果，例如分栏（不乖乖的呆着我要挣脱束缚 — 文档流，还tm有这种操作，我什么操作要你管）。 tip：其实简单的来说就是在原有的空间支持的情况下，浮起来脱离常规的文档流，那么其后边的元素就会在空间支持的情况下向上提升与其他元素平起平坐。这里的话遵循一个原则就是能浪到哪就是哪，除非有东西挡住了或者说到了父元素的边界。要不然我是不会停止的（毕竟挣脱了束缚）。 文字环绕 float的最初目的 example 1234567891011121314151617181920&lt;style&gt; .example1 span&#123;float: left;background: red;color: #fff;&#125; .example2 span&#123;float: left;backgorund: red;color: #fff;&#125;&lt;/style&gt;&lt;body&gt; &lt;!-- 通过理解行内元素换行产生空字符来理解 --&gt; &lt;!-- 1. 去空格化 --&gt; &lt;!-- 2. 会让元素block化 添加高度宽度有效果 自行测试 忘记说了 --&gt; &lt;div class="example1"&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;/div&gt; &lt;!-- html解析的回车是一个空字符 本质是&amp;nbsp; span浮动之后，空字符去哪里了。最后面 --&gt; &lt;!-- 那么其实就是文字环绕的效果 --&gt; &lt;div class="example2"&gt; &lt;span&gt;1&lt;/span&gt;&amp;nbsp;&lt;span&gt;2&lt;/span&gt;&amp;nbsp;&lt;span&gt;3&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; tip：实在不行，请脑补皇帝后宫的故事，香艳的乾清宫，姿色万分的嫔妃，皇帝也是辛苦为了做到雨露均沾，从原来的厮守交欢独宠一人，到现在的百花齐放。不得以使用了邪恶的浮动。。。此处省略1w字。但是要注意一个点浮动非图片的时候一样的效果千万不要以为只有图片可以，若不是非图片元素记得给宽高，因为图片是有宽高的。 float现代意义 分列布局 导航栏、商品列表等等 注意点：浮动的时候可能会被高度不一的元素挡住，注意调整元素的高度到合适的位置，已经父元素的空间是否足够。请记住能用浮动办到的事情请不要使用定位，因为不利于页面的后期维护，迫不得已才去使用定位。 包裹与浮动 浮动的元素脱离了文档流，必然会导致父元素高度丢失。因此不会包裹原有文档流中的子元素。这种情况不是我们想要的。 原本的元素在正常文档流中是会受父元素限制（包裹）里边的改变应该只是在内部不会去影响到外部（内部翻江倒海，外部风平浪静。或者也可以是你和一个妹妹玩角色扮演。“你叫啊，叫破喉咙也不会有人来救你”）—块级格式化上下文。当然这个不是重点。 当元素被添加了浮动之后包裹就消失父元素塌陷，并且元素还会按照浮动的方向去移动。遭到了破坏。（想那个画的图）。没办法原本的作用就是环绕，所以忍了吧。 浮动元素的margin:auto失效，没有为什么，本来就相互违背为什么要生效。 解决 清除浮动 回归文档流 明白清除浮动的目的带来的影响，浮动还是存在的，只是浮动元素对周围元素的影响以及父元素对其的包裹性。 插入元素添加属性clear：left / right / both。注意点 插入的元素必须是块级属性的元素。clear会令插入元素的margin-top/bottom失效。 伪元素的使用在于低版本的IE不支持，并且一定是给父元素添加（也一定是有浮动的父元素） 1234567891011121314151617181920212223/* 都可以 */.clearfix::after&#123; content: ''; display: block; overflow: hidden; clear: both;&#125;/* 推荐 代码少 */.clearfix::after&#123; content: ''; display: table; clear: both;&#125;/* IE8- */.clearfix&#123; display: table; clear: both;&#125;/* IE7 */.clearfix&#123;*zoom: 1;&#125; 对父元素使用overflow：hidden 解决包裹问题对父元素使用浮动（没有清除的效果，请区别对待） last有什么问题请留言！Good night~ (^_^)。]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[background]]></title>
    <url>%2F2017%2F11%2F20%2Fhtml%26css%2F07%20background%2F</url>
    <content type="text"><![CDATA[background 背景（background） 每一个盒子元素都是有图层组成，前景包含文本图片边框，元素的背景层可以使用颜色填充，背景图片层在元素的背景层之上。 简单的来说在css model中我们用一个图层的概念来理解背景。文本（图片或边框）– 背景颜色 – 背景图片 背景属性background-color 背景颜色 没什么说的。只需要思考一个问题，为什么不直接background:red 而要 background-color:red background-image 背景图片 和上边的问题一致。 background-repeat 背景重复 控制背景重复的属性有四个值。repeat（默认） 、repeat-x、repeat-y、no-repeat 默认重复，x方向重复，y方向重复，不重复。但是在使用的时候可能会碰到一些头疼的情况。比如容器尺寸和背景图片的个数恰好会让边界的背景显示的不全。CSS3提供了另外的两个属性round、space round：确保图片不被剪切，调整图片的大小适应背景区域。 space：确保图片不被剪切，添加空白来使用背景区域。 background-size 背景尺寸 CSS3规定的属性，用来控制背景图片的尺寸。 12345678910111213141516&lt;style&gt; .bg&#123; width: 500px;height: 300px;margin: 100px auto;background-image: url(xxx.jpg); background-size: cover; /* background-size: contain; */ /* background-size: 50%; */ /* background-size: 100% 50%; */ /* background-size: 500px 300px; */ &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="bg"&gt;&lt;/div&gt; &lt;div class="bg"&gt;&lt;/div&gt; &lt;div class="bg"&gt;&lt;/div&gt; &lt;div class="bg"&gt;&lt;/div&gt;&lt;/body&gt; cover：拉伸，完全填满背景区，保持宽高比。 contain：缩放，恰好适应背景区，保持宽高比。 50%：缩放，填充一半，保持宽高比。（给两个就不会保持了） 500px 300px：宽度500px，高度300px。 background-position 背景位置 控制背景图片的位置，css中提供了top、left、right、bottom、center属性，当然也可以使用px去调整。雪碧图运用。 可以去组合 example 1234567/* 需要注意的是 top right与right top 是没有区别的 *//* 只设置一个center代表水平，另一个方向会设置成center所以center center的组合和写一个center是一样的 *//* 100px 200px则是距离div左上角的位置 left 100px top 200px位置 */div&#123;background-image: url(url);background-position: center;&#125;div&#123;background-image: url(url);background-position: top left;&#125;div&#123;background-image: url(url);background-position: right bottom;&#125;div&#123;background-image: url(url);background-position: 100px 200px;&#125; background-attachment 背景粘附 默认属性是scroll，即背景图片不会随着元素滚动。设置成fixed，背景图片将不会随着页面滚动。 tip：一般用来设置水印，不随着元素的滚动而滚动。 background 简写 12345678910111213141516&lt;style&gt; body&#123; background-image: url(src); background-color: #fff; background-position: center; background-repeat: no-repeat; background-size: cover; background=attachment: fixed; &#125; /* 相当于 */ background: color url(src) no-repeat fixed center / cover ;&lt;/style&gt;&lt;body&gt; &lt;/body&gt; tip：background可以设置多个背景图片以逗号分割。 背景渐变 渐变就是在一定的范围内让颜色自然的过渡。以前是不支持的所以这个是CSS3中的属性。 分为两种一种是线性渐变（linear-gradient），一种是放射性渐变（radial-gradient）。 线性渐变 线性渐变从元素的一端延伸到另外一端 example 1234567891011121314151617181920212223242526272829&lt;style&gt; /* 默认从上到下 */ div&#123;width: 300px;height: 300px;margin: 20px auto;border: 1px solid #ddd;&#125; .bg1&#123;background: linear-gradient(#DC2EC5, #879BEA)&#125; .bg2&#123;background: linear-gradient(red, black)&#125; .bg3&#123;background: linear-gradient(#ff6600, #6CD236)&#125; /* 同时可以使用rgba也可以 */ .bg3&#123;background: -webkit-linear-gradient(left, rgba(255,255,255,.5), rgba(100,200,150,.5))&#125; /* 使用百分号也是可以的 百分号代表的是位置 */ .bg3&#123;background: -webkit-linear-gradient(left,#e86a43, #fff 25%, #64d1dd 25%, #64d1dd 75%,#fff 75%, #e86a43);&#125; .bg4&#123;background: linear-gradient(45deg,#ff6600, #6CD236)&#125; .bg5&#123;background: linear-gradient(left,#ff6600, #6CD236)&#125; /* 其实我们在设置渐变色的时候也可以设置背景图片,因为没有找到合适的图。。所以就没做出好看的 */ .class&#123; background: -webkit-linear-gradient(right, rgba(255,55,255,0), rgba(255,255,255,1)),url(src) right top no-repeat; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="bg1"&gt;&lt;/div&gt; &lt;div class="bg2"&gt;&lt;/div&gt; &lt;div class="bg3"&gt;&lt;/div&gt; &lt;div class="bg4"&gt;&lt;/div&gt; &lt;div class="bg5"&gt;&lt;/div&gt;&lt;/body&gt; tip：可以看到在bg5中需要加-webkit去兼容要不然会不起作用，在很多css3的属性中需要去声明，谷歌（webkit），火狐（moz），opera（o），IE比较特殊（ms）低版本的IE9（包括9）使用。 123body&#123; filter: progid:DXImageTransform.Microsoft.gradient(GradientType=0, startColorstr=#fff000, endColorstr=#333333);&#125; 渐变色还有很多不一样的用法有兴趣可以自己去尝试。 放射性渐变 放射听到这个词就应该知道的是发散状态，区别很显然。 example 123456789101112131415161718192021222324252627&lt;style&gt; /* 默认的渐变形状，即渐变效果会填充元素，这里的元素是矩形。如果元素是正方形，那渐变就是圆形。 */ .bg1 &#123; background: -webkit-radial-gradient(#fff, #64d1dd, #70aa25); &#125; /* 设定形状cirle,渐变形状变得均匀 (其实没看出来很大的区别) */ .bg2 &#123; background: -webkit-radial-gradient(circle, #fff, #64d1dd, #70aa25); &#125; /* 自定义位置 */ .bg3 &#123; background: -webkit-radial-gradient(50px 30px, circle, #fff, #64d1dd, #4947ba); &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="bg1"&gt;&lt;/div&gt; &lt;div class="bg2"&gt;&lt;/div&gt; &lt;div class="bg3"&gt;&lt;/div&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[font字体]]></title>
    <url>%2F2017%2F11%2F18%2Fhtml%26css%2F06%20font%2F</url>
    <content type="text"><![CDATA[CSS属性值 字体与文本 网页设计中有很多的文字要去处理，标题、段落、文章、列表以及表单中的文本。这一篇章我们讨论一下HTML中的字体与文本 字体 首先要有一个认识字体和文本不是一个东西哦。字体是不同的文本体式或者可以说是字的形体结构。对于英文来说有很多种不同的样式包括字母、数字和符号组成的。 文本指的是通过文本属性描述对文本的处理方式。行高，字符间距，缩进等。 那么网页中的字体是哪里来的呢？其中有哪些属性？文本属性中有哪些小秘密呐？ 来源 用户机器中安装的字体 保存在第三方网站上的字体（link） 保存在服务器上的字体。这些字体可以使用@font-face规则随网页一起发给浏览器（一般字体图片都会放到一个单独的服务器上，更加的优化） 字体属性font-family 字体族 font-family用于设定元素中的文本使用什么字体。通常给一个文档页面设置一个主字体（因为font-family是可以继承的），然后针对那些需要使用不用样式的字体在单独应用font-family。 因为字体来源我们已经知道了，两条路径要么是用户机器，要么是网上，那么就存在某种字体不能再某个网页中使用的可能。所以需要给出一组字体，这组字体叫做字体栈 。 简单的来说就是就是预备队，如果用户机器上没有某种字体，预备的字体就用作用了，用户还可以使用另一种字体阅读。 12345/* font-family的值不区分大小写 但是如果引入的是在线字体库请不要随意修改 有可能导致无法使用提供的定制字体*/body&#123;font-family: "Helvetica Neue", Helvetica, Arial, sans-serif；&#125; font-size 字体大小 浏览器样式表默认为每个HTML元素都设定了font-size，言外之意是我们在设置font-size的时候其实是在修改默认值。字体大小的单位px、%、em。但是有一个很重要的点是字体的大小也是可以去继承的这个地方可能会出现一些未知的错误。 px是一个很常见的单位，em也是一个单位有什么区别呢？ px绝对单位，em是一种相对单位与百分比是一样的，浏览器默认样式表在设定所有元素的字体大小时使用的都是相对单位em，h1被设定为2em，h2是1.5em，p是1em。默认情况下1em = 16px。这也是font-size的基准大小。 example 1 1234567891011&lt;style&gt; /* h1此时2em */ body&#123;font-size: 200%;&#125; /* h1此时应该是多少呢？ */ body&#123;font-size: 20px;&#125; p&#123;font-size: 16px;&#125;&lt;/style&gt;&lt;body&gt; &lt;h1&gt;我是小祺&lt;/h1&gt; &lt;p&gt;font-size&lt;/p&gt;&lt;/body&gt; tip：其它的以绝对单位设定的会重新设定字体的大小，不会产生继承。同时我们在设定的时候可以选择关键字值，比如x-small、medium 、x-large 等等 ，当然用的很少，你会在浏览器看到medium感兴趣的可以去观察一下吧。 example 2 1234567&lt;style&gt; /* span的字体大小是多少呢? */ p&#123;font-size： 80%;&#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;我是&lt;span&gt;小祺&lt;/span&gt;&lt;/p&gt;&lt;/body&gt; example 3 12345678910&lt;style&gt; /* h1的字体大小是多少呢？ */ /* span的字体大小是多少呢? */ body&#123;font-size: 150%;&#125; p&#123;font-size： 80%;&#125;&lt;/style&gt;&lt;body&gt; &lt;h1&gt;我是小祺&lt;/h1&gt; &lt;p&gt;我是&lt;span&gt;小祺&lt;/span&gt;&lt;/p&gt;&lt;/body&gt; 答案可以写在评论 ๑乛◡乛๑ tip：使用绝对单位的好处是，在祖先元素的字体大小变化时，不会出现意外的连锁反应。 font-style 字体样式 值 描述 normal 默认值。浏览器显示一个标准的字体样式。 italic 浏览器会显示一个斜体的字体样式。（斜体代表强调含义所以还是用em） oblique 浏览器会显示一个倾斜的字体样式。 inherit 规定应该从父元素继承字体样式。 font-weight 字体粗细 这个貌似没什么好说的，还是过了吧。主要一点最好使用bold、normal 当然strong标签是加粗的状态，你们应该懂我的意思。 font-variant 字体变化 值 描述 normal 默认值。浏览器会显示一个标准的字体。 small-caps 浏览器会显示小型大写字母的字体。 inherit 规定应该从父元素继承 font-variant 属性的值。 font 简写，复合写法 强调两个规则 rule 必须声明size与family。 顺序 font-weight、font-style、font-variant随意调换，其次font-size，font-family。 同时还可以设置行高 font:bold italic small-caps 16px/1.5 ‘Microsoft yahei’ 16px/1.5的这个1.5代表的是倍数。 文本属性 字体了解之后，接下来我们了解一下文本属性。缩进、角标、间距、排版等。 text-decoration 文本装饰 值 描述 none 默认。定义标准的文本。 underline 定义文本下的一条线。 overline 定义文本上的一条线。 line-through 定义穿过文本下的一条线。 blink 定义闪烁的文本。 inherit 规定应该从父元素继承 text-decoration 属性的值。 text-transform 值 描述 none 默认。定义带有小写字母和大写字母的标准的文本。 capitalize 文本中的每个单词以大写字母开头。（仅针对首字母） uppercase 定义仅有大写字母。 lowercase 定义无大写字母，仅有小写字母。 inherit 规定应该从父元素继承 text-transform 属性的值。 text-indent 文本缩进，设置文本的起点，一般我们进行首行缩进。 1p&#123;text-indent: 2em;&#125; tip：这个玩意也会继承。 example 1234567891011&lt;style type="text/css"&gt; .box&#123;text-indent: 2em;width: 400px;border: 1px solid #333;&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="box"&gt; 一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题 &lt;p&gt;一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题&lt;/p&gt; &lt;p&gt;一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题&lt;/p&gt; &lt;p&gt;一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题一个很重要的问题&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; text-algin 文本对齐方式 值 描述 left 把文本排列到左边。默认值：由浏览器决定。 right 把文本排列到右边。 center 把文本排列到中间。 justify 实现两端对齐文本效果 letter-spacing 字符间距 这个貌似也没啥说的还是过了吧。。。๑乛◡乛๑ word-spacing 单词间距，亲啊一定要区分清楚啊。 Hi girl！我只能说很少用，毕竟我们不写英文。 line-height 行高，数字。 在css里边最tm难理解的两个东西它就是其中一个。尴尬… 先来个图！ green：top（顶线） blue：middle（中线） red：baseline（基线） pink：bottom（底线） example 123456789101112131415&lt;style&gt; /* 设置字体我们可以同时设置行高，意思就是可以采用数字 2的含义是基于字体大小的倍数 通常我们不会这样子写，因为会设置字体的大小，如果是浏览器默认的值当然可以这样子写。 */ /* css中行高平均分布在一行文本的上下。 这里字体的默认大小是16px，line-height为2那么就是32px,多出来的 16px怎么会在文本的上下各填充8px。但是这样子好像有点... 直接line-height: 32px多好费劲 ⊙︿⊙. */ .p&#123;width: 200px;height: 32px;text-align: center;line-height: 2;border: 1px solid red;&#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;行高，没错就是我&lt;/p&gt;&lt;/body&gt; vertical-align 垂直对齐 以基线为参照上下移动文本，但是这个玩意只能影响行内元素 在css里边最tm难理解的另一个。 example 123456&lt;style&gt; p sub&#123;font-size:60%; vertical-align:-.4em;&#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;H&lt;sub&gt;2&lt;/sub&gt;O. 10&lt;sup&gt;5&lt;/sup&gt;&lt;/p&gt; &lt;/body&gt; tip：vertical-align通常用来让两个行内元素对齐，虽然我们有时候设置了大小行高，行内的元素有时候也无发正常居中毕竟line-height是对文字的。这里line-height与vertical-align大家知道怎么去使用碰到问题解决问题，不要深究，会死。 last最后给大家看一下字体与文本的结合，英文的排版样式布局。欣赏一下！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@import url(http://fonts.googleapis.com/css?family=Pinyon+Script);*&#123;margin: 0;padding: 0;&#125;body&#123; font-family:"CrimsonRoman", georgia, times, serif; background-color:#fff; margin:100px 10% 0;&#125;/* 设置h2的字体 文本*/h2&#123; font-size:18px; line-height:24px; font-weight:bold; text-align:center; font-variant:small-caps; word-spacing:.5em; letter-spacing:.6em;&#125;/* 设置h1的字体 文本 */h1&#123; font-size: 60px; line-height:96px; font-family:"Pinyon Script", cursive; margin:4px 0 -4px; text-align:center; font-weight:normal;&#125;p &#123; font-size:18px; line-height:24px;&#125;/* 设置长引用的边距 */blockquote &#123;margin:0px 20%;&#125;/* 设置引用字体的样式 */q &#123; font-size:18px; font-style:italic; line-height:24px;&#125;/* 首字母下沉 */h1 + p::first-letter &#123; font-family:times, serif; font-size:90px; float:left; line-height:.65; padding:.085em 3px 0 0;&#125;/* 修改第一行的文本 小型大写字母 */h1 + p::first-line &#123; font-variant:small-caps; letter-spacing:.15em;&#125;/*只缩进跟在段落后面的段落*/p + p &#123;text-indent:14px;&#125;/*引用内容前面的引号*/q::before &#123;content:"\201C"&#125;/*引用内容后面的引号*/q::after &#123;content:"\201D"&#125; 1234567891011&lt;!-- q标签 文本两端插入引号 --&gt;&lt;!-- blockquote标签 标记长引用 会给元素的前后添加边距 --&gt;&lt;h2&gt;an excerpt from&lt;/h2&gt;&lt;h1&gt;The Hound of the Baskervilles&lt;/h1&gt;&lt;p&gt;Holmes stretched out his hand for the manuscript and flattened it upon his knee. &amp;ldquo;You will observe, Watson, the alternative use of the long s and the short. It is one of several indications which enabled me to fix the date.&amp;rdquo; At the head was written: &amp;ldquo;Baskerville Hall,&amp;rdquo; and below in large, scrawling figures: &amp;ldquo;1742.&amp;rdquo;&lt;/p&gt;&lt;p&gt;&amp;ldquo;It appears to be a statement of some sort.&amp;rdquo;&lt;/p&gt;&lt;p&gt;&amp;ldquo;Yes&amp;mdash;it is a statement of a certain legend which runs in the Baskerville family.&amp;rdquo;&lt;/p&gt;&lt;blockquote&gt; &lt;q&gt;Of the origin of the Hound of the Baskervilles there have been many statements, yet as I come in a direct line from Hugo Baskerville, and as I had the story from my father&amp;hellip;&lt;/q&gt;&lt;/blockquote&gt;&lt;p&gt;When Dr. Mortimer had finished reading this singular narrative he pushed his spectacles up on his forehead and stared across at Mr. Sherlock Holmes.&lt;/p&gt; Q&amp;A1234567891011&lt;input type="button" value="按钮"&gt;&lt;input type="button" value="按钮"&gt;&lt;input type="button" value="按钮"&gt;&lt;button&gt;6&lt;/button&gt;&lt;button&gt;6&lt;/button&gt;&lt;button&gt;6&lt;/button&gt;&lt;div style="border: 1px solid #333;width:300px;"&gt; &lt;img src="url" width="300"&gt;&lt;/div&gt; 发现问题了吗? 行内元素在换行显示之后回车被html解析了。 123456789101112131415&lt;input type="button" value="按钮"&gt;&lt;input type="button" value="按钮"&gt;&lt;input type="button" value="按钮"&gt;&lt;button&gt;6&lt;/button&gt;&lt;button&gt;6&lt;/button&gt;&lt;button&gt;6&lt;/button&gt; &lt;div style="font-size:0"&gt; &lt;button&gt;6&lt;/button&gt; &lt;button&gt;6&lt;/button&gt; &lt;button&gt;6&lt;/button&gt;&lt;/div&gt;&lt;div style="border: 1px solid #333;width:300px;font-size:0;"&gt; &lt;img src="url" width="300" style="display:block"&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识css]]></title>
    <url>%2F2017%2F11%2F15%2Fhtml%26css%2F05%20css%2F</url>
    <content type="text"><![CDATA[认识 CSS — Cascading Style Sheets CSS的世界是神奇的。随着浏览器WEB标准的日趋统一，CSS在WEB世界中的扮演的角色也越来越重要。 我们从HTML开始，因为CSS的用途就是为了给HTML标记添样式，所以我们要先知道怎么去写HTML标签 什么是CSS HTML标记内容是为了给网页赋予纯粹的语义。换而言之就是为了让用户可以去理解里边的含义。每一个标签都是对所包含的内容的一种诠释，描述。所以请记住HTML 就是文本+标记的一个文档结构（请不要参杂CSS）。当我们给内容都打上标记，就可以使用CSS给标记添加样式了。添加样式的过程根据标签名、标签属性、标签等等的一些关系来给相对应的标签添加样式，so！ 先有 结构后有样式。 简单的来说CSS相当于一个神奇的化妆师，它可以去操作文档的整体表现形式，针对布局、文字、颜色、背景、动画效果等等实现精确的控制，让文档的表现更加的美观好看，它的组成是由一系列有含义的单词和数值所构成。 CSS样式可以直接存储于HTML网页或者单独的样式单文件。无论哪一种方式，样式单包含将样式应用到指定类型的元素的规则。外部使用时，样式单规则被放置在一个带有文件扩展名.css的外部样式单文档中。简单的了解这个概念之后我们来学习一些基础知识。 添加样式的三种方式有三种方法可以把CSS样式添加到网页中，分别是行内样式、嵌入样式、链接样式 12&lt;!-- 行内样式 --&gt;&lt;p style="font-size:12px;font-weight:bold;color:red;background:yellow"&gt;Hello world&lt;/p&gt; 123456&lt;!-- 嵌入样式 --&gt;&lt;head&gt; &lt;style&gt; p&#123;font-size:12px;color:red;background:yellow&#125; &lt;/style&gt;&lt;/head&gt; 1234567&lt;!-- 链接样式 --&gt;&lt;link href="style.css" rel="stylesheet" type="text/css"&gt;&lt;!-- 要注意的是@import指令必须出现在样式表其它样式之前，否则不会被加载 --&gt;&lt;style&gt; @import url(style.css); /* 注意看这里有一个分号 */&lt;/style&gt; ps ：网页的解析是从上到下，从左至右。当浏览器遇到开标签&lt;style&gt;时，就会有解析HTML代码切换成为解析CSS样式代码。再次遇到 &lt;/style&gt;时，浏览器会再次切换成为解析HTML代码 CSS规则 构成CSS规则有很多，主要就是选择器。这里我们只需要掌握常用的选择器，碰到特殊的再去查询。 命名惯例​ 选择符 {属性：值；} ​ p { color : red; } 选择器的分类 上下文选择器 一般上下文选择器 特殊上下文选择器 子选择器 &gt; 紧邻同胞 + 一般同胞 ~ id和class选择器 #id{属性：值；} .class{属性：值；} tag.class{属性：值；} 属性选择器 tag[属性名] tag[属性名=”属性值”] ps： 什么时候使用id、class、属性选择器？ id 的用途是在页面标记中唯一地标识一个特定的元素。 类是可以应用给任意多个页面中的任意多个 HTML 元素的公共标识符 。简单来说具有相同的特征的元素 基于属性名和属性的其它特征选择元素，区别对待相同标签，通过不同的标记找到适合的元素。 CSS选择器图解 我们可以通过图形来理解一下 一般选择器 123456789101112&lt;style&gt; /* 选择以p为祖先的 所有 span元素 */ p span&#123;color: red;&#125;&lt;/style&gt;&lt;body&gt; &lt;h1&gt;&lt;b&gt;一般选择器&lt;/b&gt;&lt;/h1&gt; &lt;p&gt; &lt;span&gt;this is span&lt;/span&gt; &lt;a&gt;&lt;span&gt;this is a&lt;/span&gt;&lt;/a&gt; &lt;span&gt;this is anthor span&lt;/span&gt; &lt;/p&gt;&lt;/body&gt; 特殊选择器 子选择器 &gt; 123456789101112&lt;style&gt; /* 标签1 &gt; 标签2 也就是说1必须是2的父元素 */ p &gt; span&#123;color: red;&#125;&lt;/style&gt;&lt;body&gt; &lt;h1&gt;&lt;b&gt;一般选择器&lt;/b&gt;&lt;/h1&gt; &lt;p&gt; &lt;span&gt;this is span&lt;/span&gt; &lt;a&gt;&lt;span&gt;this is a&lt;/span&gt;&lt;/a&gt; &lt;span&gt;this is anthor span&lt;/span&gt; &lt;/p&gt;&lt;/body&gt; 紧邻同胞 12345678910&lt;style&gt; /* 标签1 + 标签2 标签2必须紧跟在标签1后边 */ h1 + p&#123;color: red;&#125;&lt;/style&gt;&lt;body&gt; &lt;h1&gt;紧邻同胞&lt;/h1&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt;&lt;/body&gt; 一般同胞 12345678910&lt;style&gt; /* 标签1 ~ 标签2 标签2必须跟( 不一定紧跟 )在标签1后边 */ h1 ~ p&#123;color: red;&#125;&lt;/style&gt;&lt;body&gt; &lt;h1&gt;紧邻同胞&lt;/h1&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt;&lt;/body&gt; id、class选择器 相当于警察叔叔直接查你的身份证（唯一性）、和查你的学生证（你有很多张从小学到大学做为一个特征，你是一个学生） ps : 只不过有一个标签带类选择器 更加精确的定位特定的标签元素 (同理id选择器也具有同样的功能) 多类选择 eg: &lt;p class=”a b”&gt;&lt;/p&gt; 可以这样子去写 .a.b{color: red} 伪类 伪类会基于特定的HTML元素的状态应用样式。我们在chrome、firfox开发者工具中任意右键点击一个元素会看到一个菜单。接下来我们介绍一下伪类。Are you ready ? 链接伪类 在浏览器中样式的时候它们可以帮助我们快速的进行变换。首先介绍一下链接伪类，因为任何一个链接始终都会处于下边四个状态之一 link 链接等着用户点击 visited 用户点击过这个链接 hover 鼠标悬停在链接上 active 链接正在被点击 12345678910&lt;!-- example 使用a标签举例 --&gt;&lt;style&gt; a:link &#123;color: blue;&#125; a:visited &#123;color: green;&#125; a:hover &#123;color: red;&#125; a:active &#123;font-weight: bold;font-size: 20px;&#125;&lt;/style&gt;&lt;body&gt; &lt;a href="#"&gt;click me&lt;/a&gt;&lt;/body&gt; tip : 伪类的写法（：）一个冒号代表伪类，请务必区分和伪元素（：：）的写法，稍后看这个。看到上面的例子，可以看到a标签 也就是链接在初始的状态的时候是blue ，当鼠标悬停在上方状态为 red ，当鼠标点击链接其中的字体变大并且加粗了（为了效果而已），最后呈现的状态visited 。不过在这里地方可能会碰到一个很奇怪的问题link 当你第一次设置的时候是有效果的第二次在看这个页面的时候样式不对了，请你清除一下浏览器的缓存，并更换一下href 。 实际中不会写这么多只需要定义你所需要的， 比如用户悬停的时候给一个鲜艳的颜色，为了告诉用户快tm点我（毕竟是一个妖艳贱货๑乛◡乛๑）。如果这个链接目录很长，那么就应该使用visited 状态给一个浅的颜色，对于用户的提示作用有很大的帮助，当然也要看地方。 其它伪类、结构伪类 focus 获取焦点，表单中使用 target（不常用） 当用户点击一个指向页面中其它元素（target）的链接时，可以通过此伪类选择 first-child、last-child 代表同胞组的第一个、最后一个 nth-child(n) n代表一个数值，或者是odd奇数、even偶数 可以增强一切列表的可读性，展现不同的效果 12345&lt;!-- e:target --&gt;&lt;a href="#info"&gt;更多信息&lt;/a&gt;&lt;div id="info"&gt; &lt;h2&gt;More information&lt;/h2&gt;&lt;/div&gt; 伪元素 顾名思义，伪元素是在你的文档上时有时无的元素。介绍几个常用的，并且区分一下伪类与伪元素的区别，一些小技巧。 tip： 请记得和伪类（：）的写法区分，伪元素的写法（：：），虽然浏览器对于一个：也是支持的但是为了避免大家混乱，请遵守规则。 ::first-letter 选择首字符 ::first-line 选择文本段落第一行 ::before 在特定元素前边添加内容 ::after 在特定元素后边添加内容(用来清除浮动) example : 1234567&lt;!-- 看到效果了记得告诉我๑乛◡乛๑ --&gt;&lt;style type="text/css"&gt; p::first-letter&#123;font-size: 200%;color: red;&#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;如果你喜欢我，你可以来找我呀！&lt;/p&gt;&lt;/body&gt; 12345678910&lt;!-- first-line会随着屏幕大小改变 --&gt;&lt;style type="text/css"&gt; p::first-line&#123;color: red;font-variant:small-caps;/* 以小型大写字母展示 */&#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt; I have a dream that one day this nation will rise up and live out the true meaning of its creed: "We hold these truths to be self-evident, that all men are created equal." I have a dream that one day on the red hills of Georgia, the sons of former slaves and the sons of former slave owners will be able to sit down together at the table of brotherhood &lt;/p&gt;&lt;/body&gt; 12345678&lt;!-- before、after --&gt;&lt;style type="text/css"&gt; p::before&#123;content: '小可爱们，'&#125; p::after&#123;content: '小祺'&#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;晚上好我是&lt;/p&gt;&lt;/body&gt; ps：伪元素的能做的东西还很多以后我们在去了解。接下来我们来区分一下伪类与伪元素。 区分伪类与伪元素 伪类与伪元素是同学们最容易混淆的两个知识点。最直观的请大家通过写法初步区分。1和2的区别 example 1234567891011121314&lt;!-- 1. 通过伪类选择第一个标签并且添加红色 2. 同样我们可以使用一个类名给第一个标签添加红色--&gt;&lt;style&gt; .first&#123;color: red;&#125; /*p span:first-child&#123;color: red;&#125;*/&lt;/style&gt;&lt;body&gt; &lt;p&gt; &lt;span class="first"&gt;HTML&lt;/span&gt; &lt;span&gt;Javascript&lt;/span&gt; &lt;/p&gt;&lt;/body&gt; 12345678910111213&lt;!-- 1. 通过伪元素选择第一个字符并且添加红色 2. 同样我们可以使用一个类名给第一个字符添加红色--&gt;&lt;style&gt; .first&#123;color: red;&#125; /*p::first-letter&#123;color: red;&#125;*/&lt;/style&gt;&lt;body&gt; &lt;p&gt; &lt;span class="first"&gt;C&lt;/span&gt;ss伪元素 &lt;/p&gt;&lt;/body&gt; 到此我相信大家对CSS 的人是已经有了一定的了解了。 CSS盒子模型 提到盒子大家应该可以想到很多生活中的例子，例如纸盒、收纳盒、垃圾桶等等立体的盒子。这些盒子和CSS中的盒子有很多的相似点，都有高度宽度都可以装东西。那么我们来一起探究一下什么是盒子模型？ 概念：使用盒子模型来盛放网页中的各种元素，在网页设计中，内容指文字、图片等元素，也可以是盒子之间的嵌套。填充只有宽度高度属性，可以理解为填充物（padding），而盒子的材料厚度就是边框（大小、线性、颜色），盒子与盒子之间的距离（margin）就是间距。 Box Model CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。 盒模型的组成由width、height、border、padding、margin来描述。 margin是什么？ 例如生活中的箱子，两个箱子并排放在一起，他们两个之间的间距（margin）被称为外边距。分为上右下左四个方向。 padding是什么？ 当我们往盒子里边放了一些贵重的物品时（小心易碎！），需要在物品和盒子之间放置一些填充物，这些填充物（padding）被称为内边距。同样内边距分为上右下左四个方向。 tip：在盒子模型中，width,height指的是内容区域的的尺寸。增加内外边距不会影响内容区域的尺寸，但是会影响元素的总尺寸。 所以当我们去计算一个元素应该在页面呈现多大我们需要去合理的设置相关的属性达到我们需要的效果。 探究一下padding与margin不同的值所体现的效果。 example 1234567891011/* 四个方向 */.box&#123;margin: 0;padding: 0;&#125;/* 第一个10px代表上下 第二个10px代表左右 */.box&#123;margin: 10px 10px;padding: 10px 10px;&#125;/* 第一个10px代表上 第二个10代表左右 第三个10px代表下 */.box&#123;margin: 10px 10px 10px;padding: 10px 10px 10px;&#125;/* 第一个10px代表上 第二个10代表右 第三个10px代表下 第四个10px代表左 */.box&#123;margin: 10px 10px 10px 10px;padding: 10px 10px 10px 10px;&#125; Q&amp;A 外边距重合？margin有一个很奇怪的效果。 example 12345678910111213141516&lt;style type="text/css"&gt; .box&#123;width: 100px;height: 100px;background: red;margin: 10px 0px;&#125; .xq&#123;width: 50px;height: 50px;background: blue;margin: 30px&#125;&lt;/style&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;!-- 发现问题了吗？ 解决方法给父级元素添加overflow 或者 添加一个边框解除 --&gt; &lt;div class="box"&gt; &lt;div class="xq"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; ​]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[form表单]]></title>
    <url>%2F2017%2F11%2F15%2Fhtml%26css%2F04%20form%2F</url>
    <content type="text"><![CDATA[认识表单 什么是表单？ 表单是一个包含表单元素的区域,表单元素是允许用户在表单中（比如：文本域、下拉列表、单选框、复选框等等）输入信息的元素。 使用form标签定义 1234&lt;form action="Url" method="get"&gt; &lt;p&gt;用户名:&lt;input type="text" name="username" /&gt;&lt;/p&gt; &lt;p&gt;密码:&lt;input type="text" name="password" /&gt;&lt;/p&gt;&lt;/form&gt; input input标签的类型有很多种,以下是一些常见的类型 password button checkbox radio file hidden reset submit color date 1234567891011121314151617181920212223242526&lt;!-- eg --&gt;&lt;input type="value" value="" placeholder="请输入user"&gt;&lt;input type="password" placeholder="请输入密码"&gt;&lt;input type="checkbox" name="xq" value="1" checked&gt;&lt;input type="radio" name="sex" value="1" checked&gt;&lt;!-- checkbox(多选) name 区别于不同选项 用于拼接到url value 设置或返回单选按钮的内容 radio(单选) name 相同name只能选择一个 用于拼接到url value 设置或返回单选按钮的内容 checked 选中(写什么都可以选中 一般写true)--&gt;&lt;!-- 按钮 --&gt;&lt;input type="submit" value="提交"&gt;&lt;input type="button" value="注册"/&gt;&lt;input type="button" value="确定"&gt;&lt;input type="reset" value="重置" /&gt;&lt;input type="hidden" name="six" value="six"&gt;&lt;input type="file"&gt;&lt;input type="date" value="2017-11-15"&gt;&lt;input type="color" value="#ff0000"&gt; 12345678&lt;!-- label 增强用户的体验感--&gt;&lt;label for="basketball"&gt;篮球&lt;/label&gt;&lt;input type="radio" name="hobby" value="basketball" id="basketball" /&gt;&lt;label for="football"&gt;足球&lt;/label&gt;&lt;input type="radio" name="hobby" value="football" id="football" /&gt; textarea123&lt;textarea rows="3" cols="30" style="resize: none"&gt; 你们学到了嘛,关于表单的知识&lt;/textarea&gt; select1234567&lt;!-- size默认显示几个 --&gt;&lt;select name="size" size="3"&gt; &lt;option value="1"&gt;s&lt;/option&gt; &lt;option value="2"&gt;m&lt;/option&gt; &lt;option value="3"&gt;xl&lt;/option&gt; &lt;option value="3"&gt;xxl&lt;/option&gt;&lt;/select&gt;]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim的基本使用]]></title>
    <url>%2F2017%2F11%2F11%2Flinux%2Fvim%2FVim%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[首先了解 VIM 有三种模式，分别为：命令模式、输入模式、末行模式。刚进去的时候是处于命令模式的状态下 以下的一些操作都是基于命令模式 常用操作123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 复制 --&gt;yy 复制一行(n)yy 复制多行 eg: 6yy 复制6行y$ 复制光标到行末（包括光标）y^ 复制光标一直到行首（不包括光标）&lt;!-- 粘贴 --&gt;p 粘贴&lt;!-- 剪切/删除 --&gt;dd 剪切/删除一行(n)dd 剪切/删除多行 eg: 6dd 剪切/删除6行d$ 剪切/删除光标到行末（包括光标）d^ 剪切/删除光标一直到行首（不包括光标和空格）D 剪切/删除光标到行末（包括光标）d0 剪切/删除光标一直到行首（包括空格但是不包括光标）x 删除光标所在的字符（往后删除）X 删除光标的前一个字符 （往前删除）&lt;!--撤回--&gt;u 撤回ctrl+r 反撤回. 重复上一次操作&lt;!-- 修改 --&gt;r 修改光标所在的字符R 进入替换状态，修改多个&lt;!-- 整行后移 --&gt;&gt;&gt; 整行往后移 &lt;&lt; 整行往前移&lt;!-- 选中一块代码 --&gt;v 从光标开始位置选中多行V 选中多行&lt;!-- 查找和替换 --&gt;:%s/str1/str2/g 用str2替换全文的str1:12,20s/str1/str2/g 找出第12行到第20行的str1，并用str2替换 光标操作123456789101112131415161718192021222324&lt;!-- 上下左右 --&gt;h 左 j 下 k 上l 右&lt;!-- 翻页 --&gt;ctrl+d 向下半页ctrl+f 向下一页ctrl+u 向上半页ctrl+b 向上一页&lt;!-- 快速定位 --&gt; G 光标快速定位最后一行gg 光标快速定位第一行 H 光标快速定位可视区域内首行 M 光标快速定位可视区域内中间 L 光标快速定位可视区域内末行 &lt;!-- 移动 --&gt;0 光标跳到行首^ 光标跳到第一行的第一个非空白符$ 光标跳到行末w 光标移动到下一个单词的第一个字母b 光标移动到上一个单词的第一个字母 保存操作12345:q 退出，如果内容以改变，则不退出:q! 强制退出，不保存更改:w 保存更改:wq 保存并退出:x 保存并退出]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表，表格标签]]></title>
    <url>%2F2017%2F11%2F10%2Fhtml%26css%2F03%20tag%2F</url>
    <content type="text"><![CDATA[HTML标签之列表，表格，iframe 有序列表，无序列表 ul 无序列表标签 123456&lt;ul&gt; &lt;h3&gt;ul无序列表&lt;/h3&gt; &lt;li&gt;蒹葭苍苍，白露为霜&lt;/li&gt; &lt;li&gt;所谓伊人，在水一方&lt;/li&gt; &lt;li&gt;我就是这么的可爱!&lt;/li&gt;&lt;/ul&gt; ​ ol有序列表标签 123456&lt;ol&gt; &lt;h3&gt;ol有序列表&lt;/h3&gt; &lt;li&gt;蒹葭萋萋，白露未晞&lt;/li&gt; &lt;li&gt;所谓伊人，在水之湄&lt;/li&gt; &lt;li&gt;我就是这么的迷人!&lt;/li&gt;&lt;/ol&gt; PS：列表之间是可以相互去嵌套的，互相搭配干活不累。 列表 dl标签 1234567891011&lt;dl&gt; &lt;h3&gt;dl列表&lt;/h3&gt; &lt;dt&gt;HTML&lt;/dt&gt; &lt;dd&gt;超文本标记语言&lt;/dd&gt; &lt;dt&gt;CSS&lt;/dt&gt; &lt;dd&gt;层叠样式表&lt;/dd&gt; &lt;dt&gt;Javascript&lt;/dt&gt; &lt;dd&gt;脚本语言&lt;/dd&gt; &lt;dt&gt;JAVA&lt;/dt&gt; &lt;dd&gt;Coffice&lt;/dd&gt;&lt;/dl&gt; dt：定义列表中的项目 dd：描述列表中的项目 表格 表格 描述 &lt; table &gt; 定义表格 &lt; caption &gt; 定义表格标题。 &lt; th &gt; 定义表格的表头。 &lt; tr &gt; 定义表格的行。 &lt; td &gt; 定义表格单元。 &lt; thead &gt; 定义表格的页眉。 &lt; tbody &gt; 定义表格的主体。 &lt; tfoot &gt; 定义表格的页脚。 1234567891011&lt;!-- 垂直的表头 --&gt;&lt;table border="1" style="border-collapse: collapse;"&gt; &lt;tr&gt; &lt;th&gt; name &lt;/th&gt; &lt;th&gt; Mr.老司机寻常 &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt; size &lt;/th&gt; &lt;th&gt; 18 &lt;/th&gt; &lt;/tr&gt;&lt;/table&gt; 12345678910111213&lt;!-- 横向的表头 --&gt;&lt;table border="1" style="border-collapse: collapse;"&gt; &lt;tr&gt; &lt;th&gt; name &lt;/th&gt; &lt;th&gt; age &lt;/th&gt; &lt;th&gt; mail &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; Mr.xq &lt;/td&gt; &lt;td&gt; 18 &lt;/td&gt; &lt;td&gt; 2039971852@qq.com &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; iframe框架123&lt;!-- 写法 --&gt;&lt;iframe src="Url"&gt;&lt;/iframe&gt;&lt;!-- Url指的是iframe显示的内容地址 --&gt; 属性 值 描述 width px/% 规定 iframe 的宽度。 height px/% 规定 iframe 的高度。 frameborder 1/0 规定是否显示框架周围的边框。 scrolling yes/no/auto 规定是否在 iframe 中显示滚动条。 src URL 规定在 iframe 中显示的文档的 URL。 seamless seamless 规定在 &lt; iframe &gt; 中显示的页面的 HTML 内容。 ps：内嵌网页，加载更多，付款成功（不想跳转页面的话）]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单标签]]></title>
    <url>%2F2017%2F11%2F10%2Fhtml%26css%2F02%20tag%2F</url>
    <content type="text"><![CDATA[第二天 介绍基本的HTML标签 HTML基础标签 标题标签 h1~h6 (文章标题) div标签 ( 分割文档,形成不同的部分 ) 段落标签 p (可以将HTML文档分割成若干段落) span标签 (没什么固定的标签形式,通常用来组合) 加粗 strong/b (文字加粗功能) 斜体 em/i (文字倾斜功能) 超链接和锚标记 a (网页链接功能) 图片标签 img (网页插入图片) 特殊符号 (下列表格展示) 换行 br ( 换行 ) 割 hr ( 分割线 ) marquee ( 弹弹乐 ) PS ：h1~h6，a，img标签，i标签 使用的情况应该是什么样子的？ HTML代码 显示效果 描述 &amp;lt ; &lt; 小于号 &amp;gt ; &gt; 大于号 &amp;nbsp ; space 空格 &amp;quot ; “ 引号 &amp;copy ; © 版权 &amp;amp ; &amp; 可用于显示其它特殊字符 &amp;emsp ; space 空白位 标题标签 headerh1~h6字体大小依次降低 123456&lt;h1&gt;我是h1标签&lt;/h1&gt;&lt;h2&gt;我是h2标签&lt;/h2&gt;&lt;h3&gt;我是h3标签&lt;/h3&gt;&lt;h4&gt;我是h4标签&lt;/h4&gt;&lt;h5&gt;我是h5标签&lt;/h5&gt;&lt;h6&gt;我是h6标签&lt;/h6&gt; 段落标签 paragraph123&lt;p&gt;祝你有酒有肉有姑娘&lt;/p&gt;&lt;p&gt;祝你有诗有歌有远方&lt;/p&gt;&lt;p&gt;祝你一入java深似海,从此姑娘是路人&lt;/p&gt;]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识HTML]]></title>
    <url>%2F2017%2F11%2F10%2Fhtml%26css%2F01%20HTML%2F</url>
    <content type="text"><![CDATA[认识HTML 同学们晚上好，欢迎来到 Python Web 这个大家庭 第一天 开班典礼介绍HTML，开发工具。 HTML 历史超文本标记（HyperText Markup Language，简称为HTML）——在1993年6月作为互联网工程工作小组工作草案发布，现在使用的HTML5——2014年10月28日，W3C推荐标准。 HTML超文本标记语言，是互联网应用最广泛的标记语言。很简单的来说 $HTML$ 文件就是文本+HTML标记（也可以成为HTML标签），而不同的HTML标记能展示不同的效果。 HTML是一个很 随便 的语言，浏览器对它太宽容，也就是说想一份正确的HTML文档很简单容易，但是写一份错的HTML文档实在太难了。因为HTML也很给人一种很混乱的感觉。但是HTML本身的语法是很简单的。我们的目标就是能够掌握常用的HTML标签，以及它们的作用。其次学习CSS（层叠样式表）可以去修饰静态网页，为了后期配合脚本文件对网页的各个元素进行修饰。终极目标完成完整的静态网页的编写。 HTML文档结构，好比一个美丽的姑娘 浏览器 浏览器是我们目前会接触到最多的工具，无论是上网购物，学习，查询资料等等。为我们的日常生活提供了很多的遍历。那么我们作为一个上帝视角，有必要去了解一下我们的浏览器。 开启chrome dev tools网页工具，火狐的debug网页工具。主要以chrome为主 如何选择元素，并观察选中元素的当前状态，已经调整当前元素的状态 下载网页相关内容 使用chrome dev tools撰写前端代码，侦测元素的状态样式 chrome实用插件的安装（需要大家安装vpn，自行到谷歌下载对应的插件 以下是推荐插件列表） Type Sample Dimensions Pesticide for chrome LiveReload Javascript代码的调试 PS：熟练的掌握浏览器的dev tools工具，才能更好的运用起来 编码工具 整体课程推荐使用sublime Text3版本（和我的节奏一样最好，嘻嘻）。 编辑器只是一个我们编写代码的工具，同学们无需纠结。我们要掌握是使用工具去完成学习目标。 不要纠结，不要纠结，不要纠结 那么多的编辑器（重要的事情说 三遍 ）。 安装sublime text3软件 配置快捷键，常规工具样式（会统一发放） 安装常用的插件选项，常用模板的设置 基本快捷键的操作 PS：做好了准备工作我们就要开始我们的学习之旅了，QAQ ! 结尾 这里向大家推荐几个初学者使用的网站，平常可以多去浏览一下其中的奥义 W3C爸爸 菜鸟爸爸 送给同学们的话 风起于青萍 之末，浪成于微澜 之间 大丈夫 ，秉慧剑，般若锋兮金刚焰 昨夜西风凋碧树，独上高楼，望尽天涯路 衣带渐宽终不悔，为伊消得人憔悴 众里寻他千百度，蓦然回首，那人却在灯火阑珊处 今天的午夜电台就到这里了]]></content>
      <categories>
        <category>html&amp;css</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
</search>
